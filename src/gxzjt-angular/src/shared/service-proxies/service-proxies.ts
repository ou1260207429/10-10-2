/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AcceptanceFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectFlow (optional) 
     * @param fileCodePrefix (optional) 
     * @return Success
     */
    createApplyFile(projectFlow: ProjectFlow | null | undefined, fileCodePrefix: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateApplyFile?";
        if (fileCodePrefix !== undefined)
            url_ += "fileCodePrefix=" + encodeURIComponent("" + fileCodePrefix) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlow);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createAcceptFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateAcceptFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAcceptFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAcceptFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAcceptFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createRefuseFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateRefuseFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRefuseFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRefuseFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRefuseFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @return Success
     */
    acceptFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/AcceptFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reviewFormDto (optional) 
     * @return Success
     */
    createReviewFile(reviewFormDto: ReviewFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateReviewFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reviewFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReviewFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReviewFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReviewFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createUnqualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateUnqualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnqualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnqualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUnqualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createQualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/CreateQualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @param attachmentType (optional) 
     * @return Success
     */
    opinionFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined, attachmentType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptanceFile/OpinionFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        if (attachmentType !== undefined)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpinionFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpinionFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOpinionFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AcceptServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param flowId (optional) 
     * @return Success
     */
    getAcceptApplyForm(flowId: number | null | undefined): Observable<AcceptApplyFormDto> {
        let url_ = this.baseUrl + "/api/services/app/AcceptService/GetAcceptApplyForm?";
        if (flowId !== undefined)
            url_ += "flowId=" + encodeURIComponent("" + flowId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAcceptApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAcceptApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<AcceptApplyFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AcceptApplyFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAcceptApplyForm(response: HttpResponseBase): Observable<AcceptApplyFormDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AcceptApplyFormDto.fromJS(resultData200) : new AcceptApplyFormDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcceptApplyFormDto>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @return Success
     */
    acceptApply(acceptApplyFormDto: AcceptApplyFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcceptService/AcceptApply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptApply(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptApply(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ApplyServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param flowFormQueryDto (optional) 
     * @return Success
     */
    post_GetFlowFormData(flowFormQueryDto: FlowFormQueryDto | null | undefined): Observable<FlowFormAllDataDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/Post_GetFlowFormData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flowFormQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetFlowFormData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetFlowFormData(<any>response_);
                } catch (e) {
                    return <Observable<FlowFormAllDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlowFormAllDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetFlowFormData(response: HttpResponseBase): Observable<FlowFormAllDataDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FlowFormAllDataDto.fromJS(resultData200) : new FlowFormAllDataDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlowFormAllDataDto>(<any>null);
    }

    /**
     * @param flowFormDto (optional) 
     * @return Success
     */
    temporarySava(flowFormDto: FlowFormDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/TemporarySava";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flowFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemporarySava(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemporarySava(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processTemporarySava(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param flowDataDto (optional) 
     * @return Success
     */
    investigate(flowDataDto: FlowDataDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/Investigate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flowDataDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvestigate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvestigate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInvestigate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param flowDataDto (optional) 
     * @return Success
     */
    acceptance(flowDataDto: FlowDataDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/Acceptance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flowDataDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param flowDataDto (optional) 
     * @return Success
     */
    post_PutOnRecord(flowDataDto: FlowDataDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/Post_PutOnRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flowDataDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_PutOnRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_PutOnRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPost_PutOnRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param flowId (optional) 
     * @return Success
     */
    getReview(flowId: number | null | undefined): Observable<ReviewFormDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/GetReview?";
        if (flowId !== undefined)
            url_ += "flowId=" + encodeURIComponent("" + flowId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReview(<any>response_);
                } catch (e) {
                    return <Observable<ReviewFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReviewFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReview(response: HttpResponseBase): Observable<ReviewFormDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReviewFormDto.fromJS(resultData200) : new ReviewFormDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewFormDto>(<any>null);
    }

    /**
     * @param reviewFormDto (optional) 
     * @return Success
     */
    reviewApply(reviewFormDto: ReviewFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApplyService/ReviewApply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reviewFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewApply(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReviewApply(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    currentUser(): Observable<UserBaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/CurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCurrentUser(response: HttpResponseBase): Observable<UserBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserBaseDto.fromJS(resultData200) : new UserBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBaseDto>(<any>null);
    }

    /**
     * @param attachmentDto (optional) 
     * @return Success
     */
    addAttachmentAsync(attachmentDto: AttachmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/AddAttachmentAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attachmentDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAttachmentAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAttachmentAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAttachmentAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    attachmentListAsync(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/AttachmentListAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachmentListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachmentListAsync(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processAttachmentListAsync(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAttachmentById(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/DeleteAttachmentById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachmentById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAttachmentById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EnumConfigServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param enumId (optional) 
     * @param enumType (optional) 
     * @param parentTypeId (optional) 
     * @return Success
     */
    getEnumConfigs(enumId: number | null | undefined, enumType: string | null | undefined, parentTypeId: number | null | undefined): Observable<EnumConfig[]> {
        let url_ = this.baseUrl + "/api/services/app/EnumConfigService/GetEnumConfigs?";
        if (enumId !== undefined)
            url_ += "EnumId=" + encodeURIComponent("" + enumId) + "&"; 
        if (enumType !== undefined)
            url_ += "EnumType=" + encodeURIComponent("" + enumType) + "&"; 
        if (parentTypeId !== undefined)
            url_ += "ParentTypeId=" + encodeURIComponent("" + parentTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumConfigs(<any>response_);
                } catch (e) {
                    return <Observable<EnumConfig[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumConfig[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumConfigs(response: HttpResponseBase): Observable<EnumConfig[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumConfig.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumConfig[]>(<any>null);
    }

    /**
     * @param parentTypeId (optional) 
     * @return Success
     */
    getEnumConfigsByParent(parentTypeId: number | null | undefined): Observable<EnumConfig[]> {
        let url_ = this.baseUrl + "/api/services/app/EnumConfigService/GetEnumConfigsByParent?";
        if (parentTypeId !== undefined)
            url_ += "parentTypeId=" + encodeURIComponent("" + parentTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumConfigsByParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumConfigsByParent(<any>response_);
                } catch (e) {
                    return <Observable<EnumConfig[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumConfig[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumConfigsByParent(response: HttpResponseBase): Observable<EnumConfig[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumConfig.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumConfig[]>(<any>null);
    }

    /**
     * @param enumType (optional) 
     * @return Success
     */
    getEnumConfigsByType(enumType: string | null | undefined): Observable<EnumConfig[]> {
        let url_ = this.baseUrl + "/api/services/app/EnumConfigService/GetEnumConfigsByType?";
        if (enumType !== undefined)
            url_ += "enumType=" + encodeURIComponent("" + enumType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumConfigsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumConfigsByType(<any>response_);
                } catch (e) {
                    return <Observable<EnumConfig[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumConfig[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumConfigsByType(response: HttpResponseBase): Observable<EnumConfig[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumConfig.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumConfig[]>(<any>null);
    }

    /**
     * @param enumType (optional) 
     * @param value (optional) 
     * @return Success
     */
    getEnumConfig(enumType: string | null | undefined, value: string | null | undefined): Observable<EnumConfig> {
        let url_ = this.baseUrl + "/api/services/app/EnumConfigService/GetEnumConfig?";
        if (enumType !== undefined)
            url_ += "enumType=" + encodeURIComponent("" + enumType) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumConfig(<any>response_);
                } catch (e) {
                    return <Observable<EnumConfig>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumConfig>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumConfig(response: HttpResponseBase): Observable<EnumConfig> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EnumConfig.fromJS(resultData200) : new EnumConfig();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumConfig>(<any>null);
    }
}

@Injectable()
export class ExamineServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param flowId (optional) 
     * @return Success
     */
    getPrimaryExamine(flowId: number | null | undefined): Observable<ExamineFormDto> {
        let url_ = this.baseUrl + "/api/services/app/ExamineService/GetPrimaryExamine?";
        if (flowId !== undefined)
            url_ += "flowId=" + encodeURIComponent("" + flowId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimaryExamine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimaryExamine(<any>response_);
                } catch (e) {
                    return <Observable<ExamineFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExamineFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimaryExamine(response: HttpResponseBase): Observable<ExamineFormDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExamineFormDto.fromJS(resultData200) : new ExamineFormDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamineFormDto>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @return Success
     */
    primaryExamine(examineFormDto: ExamineFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExamineService/PrimaryExamine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrimaryExamine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrimaryExamine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrimaryExamine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @return Success
     */
    finalExamine(examineFormDto: ExamineFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExamineService/FinalExamine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalExamine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalExamine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFinalExamine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param signForDto (optional) 
     * @return Success
     */
    signForOpinionFile(signForDto: SignForDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExamineService/SignForOpinionFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(signForDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignForOpinionFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignForOpinionFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignForOpinionFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HomeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param regulationId (optional) 
     * @return Success
     */
    homeRegulationDetailsById(regulationId: number | null | undefined): Observable<RegulationDetailsViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeRegulationDetailsById?";
        if (regulationId !== undefined)
            url_ += "regulationId=" + encodeURIComponent("" + regulationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeRegulationDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeRegulationDetailsById(<any>response_);
                } catch (e) {
                    return <Observable<RegulationDetailsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegulationDetailsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processHomeRegulationDetailsById(response: HttpResponseBase): Observable<RegulationDetailsViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegulationDetailsViewModel.fromJS(resultData200) : new RegulationDetailsViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegulationDetailsViewModel>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    homeRegulationList(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeRegulationList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeRegulationList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeRegulationList(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processHomeRegulationList(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    homeNoticeList(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeNoticeList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeNoticeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeNoticeList(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processHomeNoticeList(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param noticeId (optional) 
     * @return Success
     */
    homeNoticeDetailsById(noticeId: number | null | undefined): Observable<NoticeViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeNoticeDetailsById?";
        if (noticeId !== undefined)
            url_ += "noticeId=" + encodeURIComponent("" + noticeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeNoticeDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeNoticeDetailsById(<any>response_);
                } catch (e) {
                    return <Observable<NoticeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NoticeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processHomeNoticeDetailsById(response: HttpResponseBase): Observable<NoticeViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NoticeViewModel.fromJS(resultData200) : new NoticeViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeViewModel>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    homeTableDownloadList(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeTableDownloadList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeTableDownloadList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeTableDownloadList(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processHomeTableDownloadList(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param condition (optional) 
     * @return Success
     */
    loadFireFightingInfoByCondition(condition: Condition | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Home/LoadFireFightingInfoByCondition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(condition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadFireFightingInfoByCondition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadFireFightingInfoByCondition(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processLoadFireFightingInfoByCondition(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param attachmentId (optional) 
     * @return Success
     */
    homeTableDownloadAddVisitCount(attachmentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Home/HomeTableDownloadAddVisitCount?";
        if (attachmentId !== undefined)
            url_ += "attachmentId=" + encodeURIComponent("" + attachmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeTableDownloadAddVisitCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeTableDownloadAddVisitCount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHomeTableDownloadAddVisitCount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param opt (optional) 
     * @param tableType (optional) 
     * @return Success
     */
    expPdfAndCopyFile(opt: AllOptions | null | undefined, tableType: number | null | undefined): Observable<FileResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Home/ExpPdfAndCopyFile?";
        if (tableType !== undefined)
            url_ += "TableType=" + encodeURIComponent("" + tableType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(opt);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpPdfAndCopyFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpPdfAndCopyFile(<any>response_);
                } catch (e) {
                    return <Observable<FileResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processExpPdfAndCopyFile(response: HttpResponseBase): Observable<FileResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileResultDto.fromJS(resultData200) : new FileResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAreaDropdown(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Home/GetAreaDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaDropdown(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaDropdown(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getOrganizationsByName(search: string | null | undefined): Observable<EnterpriseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Home/GetOrganizationsByName?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationsByName(<any>response_);
                } catch (e) {
                    return <Observable<EnterpriseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnterpriseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationsByName(response: HttpResponseBase): Observable<EnterpriseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnterpriseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnterpriseDto[]>(<any>null);
    }
}

@Injectable()
export class InvestigateFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectFlow (optional) 
     * @param fileCodePrefix (optional) 
     * @return Success
     */
    createApplyFile(projectFlow: ProjectFlow | null | undefined, fileCodePrefix: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/CreateApplyFile?";
        if (fileCodePrefix !== undefined)
            url_ += "fileCodePrefix=" + encodeURIComponent("" + fileCodePrefix) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlow);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createAcceptFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/CreateAcceptFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAcceptFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAcceptFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAcceptFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createRefuseFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/CreateRefuseFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRefuseFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRefuseFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRefuseFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @return Success
     */
    acceptFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/AcceptFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createUnqualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/CreateUnqualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnqualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnqualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUnqualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createQualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/CreateQualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @param attachmentType (optional) 
     * @return Success
     */
    opinionFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined, attachmentType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvestigateFile/OpinionFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        if (attachmentType !== undefined)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpinionFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpinionFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOpinionFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/services/app/Login/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentLoginUserInfoByUserId(): Observable<UserCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetCurrentLoginUserInfoByUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginUserInfoByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginUserInfoByUserId(<any>response_);
                } catch (e) {
                    return <Observable<UserCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginUserInfoByUserId(response: HttpResponseBase): Observable<UserCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserCacheDto.fromJS(resultData200) : new UserCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCacheDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getLoginUserInfoByUserId(userId: string | null | undefined): Observable<UserCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetLoginUserInfoByUserId?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginUserInfoByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginUserInfoByUserId(<any>response_);
                } catch (e) {
                    return <Observable<UserCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginUserInfoByUserId(response: HttpResponseBase): Observable<UserCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserCacheDto.fromJS(resultData200) : new UserCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    curMerchantUsers(input: PagedAndFilteredInputDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/Login/CurMerchantUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurMerchantUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurMerchantUsers(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCurMerchantUsers(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }
}

@Injectable()
export class NatureServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    post_GetSpotCheckSetupDto(): Observable<SpotCheckSetupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/NatureService/Post_GetSpotCheckSetupDto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetSpotCheckSetupDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetSpotCheckSetupDto(<any>response_);
                } catch (e) {
                    return <Observable<SpotCheckSetupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpotCheckSetupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetSpotCheckSetupDto(response: HttpResponseBase): Observable<SpotCheckSetupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SpotCheckSetupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpotCheckSetupDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    post_GetSpotCheckSetupList(): Observable<SpotChechSetupList> {
        let url_ = this.baseUrl + "/api/services/app/NatureService/Post_GetSpotCheckSetupList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetSpotCheckSetupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetSpotCheckSetupList(<any>response_);
                } catch (e) {
                    return <Observable<SpotChechSetupList>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpotChechSetupList>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetSpotCheckSetupList(response: HttpResponseBase): Observable<SpotChechSetupList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpotChechSetupList.fromJS(resultData200) : new SpotChechSetupList();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpotChechSetupList>(<any>null);
    }

    /**
     * @param spotCheckSetup (optional) 
     * @return Success
     */
    post_UpdateSpotCheckSetup(spotCheckSetup: SpotCheckSetup | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NatureService/Post_UpdateSpotCheckSetup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(spotCheckSetup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_UpdateSpotCheckSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_UpdateSpotCheckSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost_UpdateSpotCheckSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NoticeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    currentUser(): Observable<UserBaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Notice/CurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCurrentUser(response: HttpResponseBase): Observable<UserBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserBaseDto.fromJS(resultData200) : new UserBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBaseDto>(<any>null);
    }

    /**
     * @param noticeDto (optional) 
     * @return Success
     */
    addNoticeAsync(noticeDto: NoticeViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notice/AddNoticeAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(noticeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNoticeAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNoticeAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddNoticeAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    noticeListAsync(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Notice/NoticeListAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeListAsync(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processNoticeListAsync(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param noticeId (optional) 
     * @return Success
     */
    noticeDetailsByIdAsync(noticeId: number | null | undefined): Observable<NoticeViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Notice/NoticeDetailsByIdAsync?";
        if (noticeId !== undefined)
            url_ += "noticeId=" + encodeURIComponent("" + noticeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoticeDetailsByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoticeDetailsByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<NoticeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NoticeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNoticeDetailsByIdAsync(response: HttpResponseBase): Observable<NoticeViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NoticeViewModel.fromJS(resultData200) : new NoticeViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNoticeByIdAsync(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notice/DeleteNoticeByIdAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNoticeByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNoticeByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNoticeByIdAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param noticeDto (optional) 
     * @return Success
     */
    editNoticeAsync(noticeDto: NoticeViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notice/EditNoticeAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(noticeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditNoticeAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditNoticeAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditNoticeAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProjectCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    kendoGetProjectCompanys(input: DataSourceRequest | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/KendoGetProjectCompanys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKendoGetProjectCompanys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKendoGetProjectCompanys(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processKendoGetProjectCompanys(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    workFlow_ClasssListAsync(input: PagedAndFilteredInputDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/WorkFlow_ClasssListAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkFlow_ClasssListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkFlow_ClasssListAsync(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processWorkFlow_ClasssListAsync(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @return Success
     */
    getProjectCompanysAsync(): Observable<ListResultDtoOfProjectCompanyListDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/GetProjectCompanysAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectCompanysAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectCompanysAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfProjectCompanyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfProjectCompanyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectCompanysAsync(response: HttpResponseBase): Observable<ListResultDtoOfProjectCompanyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfProjectCompanyListDto.fromJS(resultData200) : new ListResultDtoOfProjectCompanyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfProjectCompanyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProjectCompanyAsync(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/DeleteProjectCompanyAsync?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProjectCompanyAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProjectCompanyAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProjectCompanyAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteProjectCompanyByIdsAsync(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/DeleteProjectCompanyByIdsAsync?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProjectCompanyByIdsAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProjectCompanyByIdsAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProjectCompanyByIdsAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateProjectCompany(input: CreateOrUpdateProjectCompanyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/CreateOrUpdateProjectCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateProjectCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateProjectCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateProjectCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createProjectCompanyAsync(input: CreateOrUpdateProjectCompanyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/CreateProjectCompanyAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectCompanyAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectCompanyAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProjectCompanyAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProjectCompanyAsync(input: CreateOrUpdateProjectCompanyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/UpdateProjectCompanyAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProjectCompanyAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProjectCompanyAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProjectCompanyAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProjectCompanyByIdAsync(id: number | null | undefined): Observable<ProjectCompanyListDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCompany/GetProjectCompanyByIdAsync?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectCompanyByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectCompanyByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<ProjectCompanyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectCompanyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectCompanyByIdAsync(response: HttpResponseBase): Observable<ProjectCompanyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectCompanyListDto.fromJS(resultData200) : new ProjectCompanyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectCompanyListDto>(<any>null);
    }
}

@Injectable()
export class ProjectFlowServcieServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectFlowItemQueryDto (optional) 
     * @return Success
     */
    post_GetProjects(projectFlowItemQueryDto: ProjectFlowItemQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetProjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlowItemQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetProjects(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetProjects(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param draftQueryDto (optional) 
     * @return Success
     */
    post_GetDrafts(draftQueryDto: DraftQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetDrafts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(draftQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetDrafts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetDrafts(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetDrafts(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param projectFlowIndexItemQueryDto (optional) 
     * @return Success
     */
    post_GetProjectFlowIndexTopCount(projectFlowIndexItemQueryDto: ProjectFlowIndexTopQueryDto | null | undefined): Observable<ProjectFlowIndexTopDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetProjectFlowIndexTopCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlowIndexItemQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetProjectFlowIndexTopCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetProjectFlowIndexTopCount(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFlowIndexTopDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFlowIndexTopDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetProjectFlowIndexTopCount(response: HttpResponseBase): Observable<ProjectFlowIndexTopDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectFlowIndexTopDto.fromJS(resultData200) : new ProjectFlowIndexTopDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFlowIndexTopDto>(<any>null);
    }

    /**
     * @param projectTimeoutQueryDto (optional) 
     * @return Success
     */
    post_GetProjectsTimeout(projectTimeoutQueryDto: ProjectTimeoutQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetProjectsTimeout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectTimeoutQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetProjectsTimeout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetProjectsTimeout(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetProjectsTimeout(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param projectFlowStatisticsDto (optional) 
     * @return Success
     */
    post_GetProjectFlowDataStatistics(projectFlowStatisticsDto: ProjectFlowDataStatisticsQueryDto | null | undefined): Observable<ProjectFlowStatisticsDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetProjectFlowDataStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlowStatisticsDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetProjectFlowDataStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetProjectFlowDataStatistics(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFlowStatisticsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFlowStatisticsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetProjectFlowDataStatistics(response: HttpResponseBase): Observable<ProjectFlowStatisticsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectFlowStatisticsDto.fromJS(resultData200) : new ProjectFlowStatisticsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFlowStatisticsDto>(<any>null);
    }

    /**
     * @param fireAuditCompleteQueryDto (optional) 
     * @return Success
     */
    post_GetFireAuditCompleteList(fireAuditCompleteQueryDto: FireAuditCompleteQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetFireAuditCompleteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fireAuditCompleteQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetFireAuditCompleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetFireAuditCompleteList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetFireAuditCompleteList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param statisticsQueryDto (optional) 
     * @return Success
     */
    post_GetStatisticsList(statisticsQueryDto: StatisticsQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ProjectFlowServcie/Post_GetStatisticsList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(statisticsQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetStatisticsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetStatisticsList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetStatisticsList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }
}

@Injectable()
export class PutOnRecordFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectFlow (optional) 
     * @param fileCodePrefix (optional) 
     * @return Success
     */
    createApplyFile(projectFlow: ProjectFlow | null | undefined, fileCodePrefix: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateApplyFile?";
        if (fileCodePrefix !== undefined)
            url_ += "fileCodePrefix=" + encodeURIComponent("" + fileCodePrefix) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectFlow);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createAcceptFileBySelect(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateAcceptFileBySelect?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAcceptFileBySelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAcceptFileBySelect(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAcceptFileBySelect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createAcceptFileByNotSelect(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateAcceptFileByNotSelect?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAcceptFileByNotSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAcceptFileByNotSelect(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAcceptFileByNotSelect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createMakeupFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateMakeupFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMakeupFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMakeupFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMakeupFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param acceptApplyFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @param attachmentType (optional) 
     * @return Success
     */
    acceptFile(acceptApplyFormDto: AcceptApplyFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined, attachmentType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/AcceptFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        if (attachmentType !== undefined)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptApplyFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reviewFormDto (optional) 
     * @return Success
     */
    createReviewFile(reviewFormDto: ReviewFormDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateReviewFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reviewFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReviewFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReviewFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReviewFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createUnqualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateUnqualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnqualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnqualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUnqualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @return Success
     */
    createQualifiedFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/CreateQualifiedFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQualifiedFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQualifiedFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQualifiedFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param examineFormDto (optional) 
     * @param acceptRecordId (optional) 
     * @param template (optional) 
     * @param attachmentType (optional) 
     * @return Success
     */
    opinionFile(examineFormDto: ExamineFormDto | null | undefined, acceptRecordId: number | null | undefined, template: string | null | undefined, attachmentType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutOnRecordFile/OpinionFile?";
        if (acceptRecordId !== undefined)
            url_ += "acceptRecordId=" + encodeURIComponent("" + acceptRecordId) + "&"; 
        if (template !== undefined)
            url_ += "template=" + encodeURIComponent("" + template) + "&"; 
        if (attachmentType !== undefined)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(examineFormDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpinionFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpinionFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOpinionFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RegulationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    currentUser(): Observable<UserBaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/CurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCurrentUser(response: HttpResponseBase): Observable<UserBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserBaseDto.fromJS(resultData200) : new UserBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBaseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    kendoGetRegulations(input: DataSourceRequest | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/KendoGetRegulations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKendoGetRegulations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKendoGetRegulations(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processKendoGetRegulations(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    workFlow_ClasssListAsync(input: PagedAndFilteredInputDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/WorkFlow_ClasssListAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkFlow_ClasssListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkFlow_ClasssListAsync(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processWorkFlow_ClasssListAsync(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @return Success
     */
    getRegulationsAsync(): Observable<ListResultDtoOfRegulationListDto> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/GetRegulationsAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegulationsAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegulationsAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRegulationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRegulationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegulationsAsync(response: HttpResponseBase): Observable<ListResultDtoOfRegulationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRegulationListDto.fromJS(resultData200) : new ListResultDtoOfRegulationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRegulationListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRegulationAsync(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/DeleteRegulationAsync?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegulationAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegulationAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRegulationAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteRegulationByIdsAsync(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/DeleteRegulationByIdsAsync?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegulationByIdsAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegulationByIdsAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRegulationByIdsAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRegulation(input: CreateOrUpdateRegulationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/CreateOrUpdateRegulation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRegulation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRegulation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRegulation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createRegulationAsync(input: CreateOrUpdateRegulationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/CreateRegulationAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRegulationAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRegulationAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRegulationAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateRegulationAsync(input: CreateOrUpdateRegulationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/UpdateRegulationAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRegulationAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRegulationAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRegulationAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRegulationByIdAsync(id: number | null | undefined): Observable<RegulationListDto> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/GetRegulationByIdAsync?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegulationByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegulationByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<RegulationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegulationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegulationByIdAsync(response: HttpResponseBase): Observable<RegulationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegulationListDto.fromJS(resultData200) : new RegulationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegulationListDto>(<any>null);
    }

    /**
     * @param regulationDto (optional) 
     * @return Success
     */
    addRegulationAsync(regulationDto: RegulationDetailsViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/AddRegulationAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(regulationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRegulationAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRegulationAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRegulationAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @return Success
     */
    regulationListAsync(pageSize: PageSize | null | undefined): Observable<PageModel> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/RegulationListAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSize);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegulationListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegulationListAsync(<any>response_);
                } catch (e) {
                    return <Observable<PageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegulationListAsync(response: HttpResponseBase): Observable<PageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageModel.fromJS(resultData200) : new PageModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageModel>(<any>null);
    }

    /**
     * @param regulationId (optional) 
     * @return Success
     */
    getRegulationDetailsByIdAsync(regulationId: number | null | undefined): Observable<RegulationDetailsViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/GetRegulationDetailsByIdAsync?";
        if (regulationId !== undefined)
            url_ += "regulationId=" + encodeURIComponent("" + regulationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegulationDetailsByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegulationDetailsByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<RegulationDetailsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegulationDetailsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegulationDetailsByIdAsync(response: HttpResponseBase): Observable<RegulationDetailsViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegulationDetailsViewModel.fromJS(resultData200) : new RegulationDetailsViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegulationDetailsViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRegulationByIdAsync(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/DeleteRegulationByIdAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegulationByIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegulationByIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRegulationByIdAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param regulationDto (optional) 
     * @return Success
     */
    editRegulationAsync(regulationDto: RegulationDetailsViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/EditRegulationAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(regulationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRegulationAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRegulationAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditRegulationAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param enumType (optional) 
     * @return Success
     */
    getDropdownTypeByEnumType(enumType: string | null | undefined): Observable<KeyValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Regulation/GetDropdownTypeByEnumType?";
        if (enumType !== undefined)
            url_ += "enumType=" + encodeURIComponent("" + enumType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropdownTypeByEnumType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropdownTypeByEnumType(<any>response_);
                } catch (e) {
                    return <Observable<KeyValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropdownTypeByEnumType(response: HttpResponseBase): Observable<KeyValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KeyValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValueDto[]>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class ScreenServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param applyStatisticsQueryDto (optional) 
     * @return Success
     */
    post_GetApplyStatistics(applyStatisticsQueryDto: ApplyStatisticsQueryDto | null | undefined): Observable<ApplyStatisticsDto> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetApplyStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applyStatisticsQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetApplyStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetApplyStatistics(<any>response_);
                } catch (e) {
                    return <Observable<ApplyStatisticsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplyStatisticsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetApplyStatistics(response: HttpResponseBase): Observable<ApplyStatisticsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplyStatisticsDto.fromJS(resultData200) : new ApplyStatisticsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplyStatisticsDto>(<any>null);
    }

    /**
     * @param declareRateQueryDto (optional) 
     * @return Success
     */
    post_GetDeclareRate(declareRateQueryDto: DeclareRateQueryDto | null | undefined): Observable<ListResultDtoOfTimeoutStatisticsDto> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetDeclareRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(declareRateQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetDeclareRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetDeclareRate(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfTimeoutStatisticsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfTimeoutStatisticsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetDeclareRate(response: HttpResponseBase): Observable<ListResultDtoOfTimeoutStatisticsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfTimeoutStatisticsDto.fromJS(resultData200) : new ListResultDtoOfTimeoutStatisticsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfTimeoutStatisticsDto>(<any>null);
    }

    /**
     * @param screenTimeoutStatisticsQueryDto (optional) 
     * @return Success
     */
    post_GetScreenCityTimeoutStatistics(screenTimeoutStatisticsQueryDto: ScreenTimeoutStatisticsQueryDto | null | undefined): Observable<ListResultDtoOfTimeoutStatisticsDto> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetScreenCityTimeoutStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(screenTimeoutStatisticsQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetScreenCityTimeoutStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetScreenCityTimeoutStatistics(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfTimeoutStatisticsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfTimeoutStatisticsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetScreenCityTimeoutStatistics(response: HttpResponseBase): Observable<ListResultDtoOfTimeoutStatisticsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfTimeoutStatisticsDto.fromJS(resultData200) : new ListResultDtoOfTimeoutStatisticsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfTimeoutStatisticsDto>(<any>null);
    }

    /**
     * @return Success
     */
    post_GetATimeByStatistics(): Observable<ListResultDtoOfATimeByStatisticsDto> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetATimeByStatistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetATimeByStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetATimeByStatistics(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfATimeByStatisticsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfATimeByStatisticsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetATimeByStatistics(response: HttpResponseBase): Observable<ListResultDtoOfATimeByStatisticsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfATimeByStatisticsDto.fromJS(resultData200) : new ListResultDtoOfATimeByStatisticsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfATimeByStatisticsDto>(<any>null);
    }

    /**
     * @param screenTimeoutListQueryDto (optional) 
     * @return Success
     */
    post_GetScreenTimeoutList(screenTimeoutListQueryDto: ScreenTimeoutListQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetScreenTimeoutList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(screenTimeoutListQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetScreenTimeoutList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetScreenTimeoutList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetScreenTimeoutList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param yearApplyNumberQueryDto (optional) 
     * @return Success
     */
    post_GetScreenYearApplyNumber(yearApplyNumberQueryDto: YearApplyNumberQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetScreenYearApplyNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(yearApplyNumberQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetScreenYearApplyNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetScreenYearApplyNumber(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetScreenYearApplyNumber(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param fireDataListQueryDto (optional) 
     * @return Success
     */
    post_GetFireDataList(fireDataListQueryDto: FireDataListQueryDto | null | undefined): Observable<FireDataListDto> {
        let url_ = this.baseUrl + "/api/services/app/ScreenService/Post_GetFireDataList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fireDataListQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetFireDataList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetFireDataList(<any>response_);
                } catch (e) {
                    return <Observable<FireDataListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FireDataListDto>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetFireDataList(response: HttpResponseBase): Observable<FireDataListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FireDataListDto.fromJS(resultData200) : new FireDataListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FireDataListDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class StatisticalServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param warningCenterQueryDto (optional) 
     * @return Success
     */
    post_GetWarningCenterList(warningCenterQueryDto: WarningCenterQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/StatisticalService/Post_GetWarningCenterList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(warningCenterQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetWarningCenterList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetWarningCenterList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetWarningCenterList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param projectApplyQueryDto (optional) 
     * @return Success
     */
    post_GetProjectApplyList(projectApplyQueryDto: ProjectApplyQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/StatisticalService/Post_GetProjectApplyList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectApplyQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetProjectApplyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetProjectApplyList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetProjectApplyList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param timeoutQuetyDto (optional) 
     * @return Success
     */
    post_GetTimeoutList(timeoutQuetyDto: TimeoutQuetyDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/StatisticalService/Post_GetTimeoutList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(timeoutQuetyDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetTimeoutList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetTimeoutList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetTimeoutList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param handleLimitQueryDto (optional) 
     * @return Success
     */
    post_GetHandleLimitList(handleLimitQueryDto: HandleLimitQueryDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/StatisticalService/Post_GetHandleLimitList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(handleLimitQueryDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost_GetHandleLimitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost_GetHandleLimitList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost_GetHandleLimitList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class UserHelperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    currentUser(): Observable<UserBaseDto> {
        let url_ = this.baseUrl + "/api/services/app/UserHelper/CurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCurrentUser(response: HttpResponseBase): Observable<UserBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserBaseDto.fromJS(resultData200) : new UserBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBaseDto>(<any>null);
    }

    /**
     * @param flowId (optional) 
     * @return Success
     */
    currentFlowNodeUser(flowId: number | null | undefined): Observable<FlowNodeUser> {
        let url_ = this.baseUrl + "/api/services/app/UserHelper/CurrentFlowNodeUser?";
        if (flowId !== undefined)
            url_ += "flowId=" + encodeURIComponent("" + flowId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentFlowNodeUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentFlowNodeUser(<any>response_);
                } catch (e) {
                    return <Observable<FlowNodeUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlowNodeUser>><any>_observableThrow(response_);
        }));
    }

    protected processCurrentFlowNodeUser(response: HttpResponseBase): Observable<FlowNodeUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FlowNodeUser.fromJS(resultData200) : new FlowNodeUser();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlowNodeUser>(<any>null);
    }
}

@Injectable()
export class WorkFlowedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    pendingWorkFlow_NodeAuditorRecord(input: PendingWorkFlow_NodeAuditorRecordDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlowed/PendingWorkFlow_NodeAuditorRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPendingWorkFlow_NodeAuditorRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPendingWorkFlow_NodeAuditorRecord(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processPendingWorkFlow_NodeAuditorRecord(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    processedWorkFlow_NodeAuditorRecord(input: PendingWorkFlow_NodeAuditorRecordDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlowed/ProcessedWorkFlow_NodeAuditorRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessedWorkFlow_NodeAuditorRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessedWorkFlow_NodeAuditorRecord(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processProcessedWorkFlow_NodeAuditorRecord(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    queryWorkFlow_InstanceList(input: PendingWorkFlow_NodeAuditorRecordDto | null | undefined): Observable<DataSourceResult> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlowed/QueryWorkFlow_InstanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryWorkFlow_InstanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryWorkFlow_InstanceList(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processQueryWorkFlow_InstanceList(response: HttpResponseBase): Observable<DataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResult.fromJS(resultData200) : new DataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResult>(<any>null);
    }
}

export class ProjectFlow implements IProjectFlow {
    projectId: number | undefined;
    flowPathType: number | undefined;
    flowNo: string | undefined;
    applyTime: moment.Moment | undefined;
    applyUserCode: string | undefined;
    applyName: string | undefined;
    status: number | undefined;
    endTime: moment.Moment | undefined;
    expireTime: moment.Moment | undefined;
    applyingForms: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    recordNumber: string | undefined;
    timeLimit: number | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    parentFlowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IProjectFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.flowPathType = data["flowPathType"];
            this.flowNo = data["flowNo"];
            this.applyTime = data["applyTime"] ? moment(data["applyTime"].toString()) : <any>undefined;
            this.applyUserCode = data["applyUserCode"];
            this.applyName = data["applyName"];
            this.status = data["status"];
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.expireTime = data["expireTime"] ? moment(data["expireTime"].toString()) : <any>undefined;
            this.applyingForms = data["applyingForms"];
            this.currentHandleUserName = data["currentHandleUserName"];
            this.currentHandleUserCode = data["currentHandleUserCode"];
            this.currentNodeId = data["currentNodeId"];
            this.currentNodeName = data["currentNodeName"];
            this.recordNumber = data["recordNumber"];
            this.timeLimit = data["timeLimit"];
            this.nodeAuditorRecordId = data["nodeAuditorRecordId"];
            this.workFlow_NodeRecord_Id = data["workFlow_NodeRecord_Id"];
            this.workFlow_Instance_Id = data["workFlow_Instance_Id"];
            this.workFlow_TemplateInfo_Id = data["workFlow_TemplateInfo_Id"];
            this.parentFlowId = data["parentFlowId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectFlow {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["flowPathType"] = this.flowPathType;
        data["flowNo"] = this.flowNo;
        data["applyTime"] = this.applyTime ? this.applyTime.toISOString() : <any>undefined;
        data["applyUserCode"] = this.applyUserCode;
        data["applyName"] = this.applyName;
        data["status"] = this.status;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["applyingForms"] = this.applyingForms;
        data["currentHandleUserName"] = this.currentHandleUserName;
        data["currentHandleUserCode"] = this.currentHandleUserCode;
        data["currentNodeId"] = this.currentNodeId;
        data["currentNodeName"] = this.currentNodeName;
        data["recordNumber"] = this.recordNumber;
        data["timeLimit"] = this.timeLimit;
        data["nodeAuditorRecordId"] = this.nodeAuditorRecordId;
        data["workFlow_NodeRecord_Id"] = this.workFlow_NodeRecord_Id;
        data["workFlow_Instance_Id"] = this.workFlow_Instance_Id;
        data["workFlow_TemplateInfo_Id"] = this.workFlow_TemplateInfo_Id;
        data["parentFlowId"] = this.parentFlowId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProjectFlow {
        const json = this.toJSON();
        let result = new ProjectFlow();
        result.init(json);
        return result;
    }
}

export interface IProjectFlow {
    projectId: number | undefined;
    flowPathType: number | undefined;
    flowNo: string | undefined;
    applyTime: moment.Moment | undefined;
    applyUserCode: string | undefined;
    applyName: string | undefined;
    status: number | undefined;
    endTime: moment.Moment | undefined;
    expireTime: moment.Moment | undefined;
    applyingForms: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    recordNumber: string | undefined;
    timeLimit: number | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    parentFlowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class AcceptApplyFormDto implements IAcceptApplyFormDto {
    isAccept: boolean | undefined;
    isComplete: boolean | undefined;
    flowId: number | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    refuseItems: RefuseItem[] | undefined;
    fileCodePrefix: string | undefined;
    companyName: string | undefined;
    applyDateTime: moment.Moment | undefined;
    address: string | undefined;
    shortAddress: string | undefined;
    attachmentItems: AttachmentItem[] | undefined;
    timeLimit: number | undefined;
    timeLimitOfDay: number | undefined;
    projectId: number | undefined;
    projectName: string | undefined;
    completeContent: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNodeUserInfo: FlowNodeUser | undefined;
    flowNodeItems: FlowNodeItem[] | undefined;
    isSelect: boolean | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    regionAndCountyName: string | undefined;
    area: string | undefined;
    acceptFileCode: string | undefined;
    flowPathType: number | undefined;

    constructor(data?: IAcceptApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAccept = data["isAccept"];
            this.isComplete = data["isComplete"];
            this.flowId = data["flowId"];
            this.currentHandleUserName = data["currentHandleUserName"];
            this.currentHandleUserCode = data["currentHandleUserCode"];
            if (data["handleUserList"] && data["handleUserList"].constructor === Array) {
                this.handleUserList = [];
                for (let item of data["handleUserList"])
                    this.handleUserList.push(FlowNodeUser.fromJS(item));
            }
            this.currentNodeId = data["currentNodeId"];
            this.currentNodeName = data["currentNodeName"];
            this.currentHandleOrgName = data["currentHandleOrgName"];
            this.currentHandleOrgCode = data["currentHandleOrgCode"];
            if (data["refuseItems"] && data["refuseItems"].constructor === Array) {
                this.refuseItems = [];
                for (let item of data["refuseItems"])
                    this.refuseItems.push(RefuseItem.fromJS(item));
            }
            this.fileCodePrefix = data["fileCodePrefix"];
            this.companyName = data["companyName"];
            this.applyDateTime = data["applyDateTime"] ? moment(data["applyDateTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.shortAddress = data["shortAddress"];
            if (data["attachmentItems"] && data["attachmentItems"].constructor === Array) {
                this.attachmentItems = [];
                for (let item of data["attachmentItems"])
                    this.attachmentItems.push(AttachmentItem.fromJS(item));
            }
            this.timeLimit = data["timeLimit"];
            this.timeLimitOfDay = data["timeLimitOfDay"];
            this.projectId = data["projectId"];
            this.projectName = data["projectName"];
            this.completeContent = data["completeContent"];
            this.nodeAuditorRecordId = data["nodeAuditorRecordId"];
            this.workFlow_NodeRecord_Id = data["workFlow_NodeRecord_Id"];
            this.workFlow_Instance_Id = data["workFlow_Instance_Id"];
            this.workFlow_TemplateInfo_Id = data["workFlow_TemplateInfo_Id"];
            this.flowNodeUserInfo = data["flowNodeUserInfo"] ? FlowNodeUser.fromJS(data["flowNodeUserInfo"]) : <any>undefined;
            if (data["flowNodeItems"] && data["flowNodeItems"].constructor === Array) {
                this.flowNodeItems = [];
                for (let item of data["flowNodeItems"])
                    this.flowNodeItems.push(FlowNodeItem.fromJS(item));
            }
            this.isSelect = data["isSelect"];
            this.provinceName = data["provinceName"];
            this.cityName = data["cityName"];
            this.regionAndCountyName = data["regionAndCountyName"];
            this.area = data["area"];
            this.acceptFileCode = data["acceptFileCode"];
            this.flowPathType = data["flowPathType"];
        }
    }

    static fromJS(data: any): AcceptApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAccept"] = this.isAccept;
        data["isComplete"] = this.isComplete;
        data["flowId"] = this.flowId;
        data["currentHandleUserName"] = this.currentHandleUserName;
        data["currentHandleUserCode"] = this.currentHandleUserCode;
        if (this.handleUserList && this.handleUserList.constructor === Array) {
            data["handleUserList"] = [];
            for (let item of this.handleUserList)
                data["handleUserList"].push(item.toJSON());
        }
        data["currentNodeId"] = this.currentNodeId;
        data["currentNodeName"] = this.currentNodeName;
        data["currentHandleOrgName"] = this.currentHandleOrgName;
        data["currentHandleOrgCode"] = this.currentHandleOrgCode;
        if (this.refuseItems && this.refuseItems.constructor === Array) {
            data["refuseItems"] = [];
            for (let item of this.refuseItems)
                data["refuseItems"].push(item.toJSON());
        }
        data["fileCodePrefix"] = this.fileCodePrefix;
        data["companyName"] = this.companyName;
        data["applyDateTime"] = this.applyDateTime ? this.applyDateTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["shortAddress"] = this.shortAddress;
        if (this.attachmentItems && this.attachmentItems.constructor === Array) {
            data["attachmentItems"] = [];
            for (let item of this.attachmentItems)
                data["attachmentItems"].push(item.toJSON());
        }
        data["timeLimit"] = this.timeLimit;
        data["timeLimitOfDay"] = this.timeLimitOfDay;
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["completeContent"] = this.completeContent;
        data["nodeAuditorRecordId"] = this.nodeAuditorRecordId;
        data["workFlow_NodeRecord_Id"] = this.workFlow_NodeRecord_Id;
        data["workFlow_Instance_Id"] = this.workFlow_Instance_Id;
        data["workFlow_TemplateInfo_Id"] = this.workFlow_TemplateInfo_Id;
        data["flowNodeUserInfo"] = this.flowNodeUserInfo ? this.flowNodeUserInfo.toJSON() : <any>undefined;
        if (this.flowNodeItems && this.flowNodeItems.constructor === Array) {
            data["flowNodeItems"] = [];
            for (let item of this.flowNodeItems)
                data["flowNodeItems"].push(item.toJSON());
        }
        data["isSelect"] = this.isSelect;
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["regionAndCountyName"] = this.regionAndCountyName;
        data["area"] = this.area;
        data["acceptFileCode"] = this.acceptFileCode;
        data["flowPathType"] = this.flowPathType;
        return data; 
    }

    clone(): AcceptApplyFormDto {
        const json = this.toJSON();
        let result = new AcceptApplyFormDto();
        result.init(json);
        return result;
    }
}

export interface IAcceptApplyFormDto {
    isAccept: boolean | undefined;
    isComplete: boolean | undefined;
    flowId: number | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    refuseItems: RefuseItem[] | undefined;
    fileCodePrefix: string | undefined;
    companyName: string | undefined;
    applyDateTime: moment.Moment | undefined;
    address: string | undefined;
    shortAddress: string | undefined;
    attachmentItems: AttachmentItem[] | undefined;
    timeLimit: number | undefined;
    timeLimitOfDay: number | undefined;
    projectId: number | undefined;
    projectName: string | undefined;
    completeContent: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNodeUserInfo: FlowNodeUser | undefined;
    flowNodeItems: FlowNodeItem[] | undefined;
    isSelect: boolean | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    regionAndCountyName: string | undefined;
    area: string | undefined;
    acceptFileCode: string | undefined;
    flowPathType: number | undefined;
}

export class FlowNodeUser implements IFlowNodeUser {
    userCode: string | undefined;
    userName: string | undefined;
    userFlowId: string | undefined;
    nodeId: string | undefined;
    flowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IFlowNodeUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userCode = data["userCode"];
            this.userName = data["userName"];
            this.userFlowId = data["userFlowId"];
            this.nodeId = data["nodeId"];
            this.flowId = data["flowId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FlowNodeUser {
        data = typeof data === 'object' ? data : {};
        let result = new FlowNodeUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userCode"] = this.userCode;
        data["userName"] = this.userName;
        data["userFlowId"] = this.userFlowId;
        data["nodeId"] = this.nodeId;
        data["flowId"] = this.flowId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): FlowNodeUser {
        const json = this.toJSON();
        let result = new FlowNodeUser();
        result.init(json);
        return result;
    }
}

export interface IFlowNodeUser {
    userCode: string | undefined;
    userName: string | undefined;
    userFlowId: string | undefined;
    nodeId: string | undefined;
    flowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class RefuseItem implements IRefuseItem {
    itemId: number | undefined;
    name: string | undefined;
    describe: string | undefined;

    constructor(data?: IRefuseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemId = data["itemId"];
            this.name = data["name"];
            this.describe = data["describe"];
        }
    }

    static fromJS(data: any): RefuseItem {
        data = typeof data === 'object' ? data : {};
        let result = new RefuseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["name"] = this.name;
        data["describe"] = this.describe;
        return data; 
    }

    clone(): RefuseItem {
        const json = this.toJSON();
        let result = new RefuseItem();
        result.init(json);
        return result;
    }
}

export interface IRefuseItem {
    itemId: number | undefined;
    name: string | undefined;
    describe: string | undefined;
}

export class AttachmentItem implements IAttachmentItem {
    id: number | undefined;
    attachmentTypeName: string | undefined;
    attachmentType: string | undefined;
    fileUrl: string | undefined;
    note: string | undefined;
    fileCount: number | undefined;
    isSubmit: boolean | undefined;
    fileNo: number | undefined;
    flieCode: string | undefined;
    flowId: number | undefined;

    constructor(data?: IAttachmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.attachmentTypeName = data["attachmentTypeName"];
            this.attachmentType = data["attachmentType"];
            this.fileUrl = data["fileUrl"];
            this.note = data["note"];
            this.fileCount = data["fileCount"];
            this.isSubmit = data["isSubmit"];
            this.fileNo = data["fileNo"];
            this.flieCode = data["flieCode"];
            this.flowId = data["flowId"];
        }
    }

    static fromJS(data: any): AttachmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attachmentTypeName"] = this.attachmentTypeName;
        data["attachmentType"] = this.attachmentType;
        data["fileUrl"] = this.fileUrl;
        data["note"] = this.note;
        data["fileCount"] = this.fileCount;
        data["isSubmit"] = this.isSubmit;
        data["fileNo"] = this.fileNo;
        data["flieCode"] = this.flieCode;
        data["flowId"] = this.flowId;
        return data; 
    }

    clone(): AttachmentItem {
        const json = this.toJSON();
        let result = new AttachmentItem();
        result.init(json);
        return result;
    }
}

export interface IAttachmentItem {
    id: number | undefined;
    attachmentTypeName: string | undefined;
    attachmentType: string | undefined;
    fileUrl: string | undefined;
    note: string | undefined;
    fileCount: number | undefined;
    isSubmit: boolean | undefined;
    fileNo: number | undefined;
    flieCode: string | undefined;
    flowId: number | undefined;
}

export class FlowNodeItem implements IFlowNodeItem {
    isDisplayFile: boolean | undefined;
    isPass: boolean | undefined;
    opinion: string | undefined;
    describe: string | undefined;
    fileUrl: string | undefined;
    fileFlag: string | undefined;
    fileName: string | undefined;
    currentNodeName: string | undefined;

    constructor(data?: IFlowNodeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDisplayFile = data["isDisplayFile"];
            this.isPass = data["isPass"];
            this.opinion = data["opinion"];
            this.describe = data["describe"];
            this.fileUrl = data["fileUrl"];
            this.fileFlag = data["fileFlag"];
            this.fileName = data["fileName"];
            this.currentNodeName = data["currentNodeName"];
        }
    }

    static fromJS(data: any): FlowNodeItem {
        data = typeof data === 'object' ? data : {};
        let result = new FlowNodeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDisplayFile"] = this.isDisplayFile;
        data["isPass"] = this.isPass;
        data["opinion"] = this.opinion;
        data["describe"] = this.describe;
        data["fileUrl"] = this.fileUrl;
        data["fileFlag"] = this.fileFlag;
        data["fileName"] = this.fileName;
        data["currentNodeName"] = this.currentNodeName;
        return data; 
    }

    clone(): FlowNodeItem {
        const json = this.toJSON();
        let result = new FlowNodeItem();
        result.init(json);
        return result;
    }
}

export interface IFlowNodeItem {
    isDisplayFile: boolean | undefined;
    isPass: boolean | undefined;
    opinion: string | undefined;
    describe: string | undefined;
    fileUrl: string | undefined;
    fileFlag: string | undefined;
    fileName: string | undefined;
    currentNodeName: string | undefined;
}

export class ReviewFormDto implements IReviewFormDto {
    fileCodePrefix: string | undefined;
    projectId: number | undefined;
    flowId: number | undefined;
    constructOrg: ProjectCompany | undefined;
    projectName: string | undefined;
    projectCode: string | undefined;
    address: string | undefined;
    recordFileCode: string | undefined;
    unqualifiedFileCode: string | undefined;
    situation: string | undefined;
    note: string | undefined;
    applyName: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    timeLimit: number | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNo: string | undefined;
    area: string | undefined;

    constructor(data?: IReviewFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileCodePrefix = data["fileCodePrefix"];
            this.projectId = data["projectId"];
            this.flowId = data["flowId"];
            this.constructOrg = data["constructOrg"] ? ProjectCompany.fromJS(data["constructOrg"]) : <any>undefined;
            this.projectName = data["projectName"];
            this.projectCode = data["projectCode"];
            this.address = data["address"];
            this.recordFileCode = data["recordFileCode"];
            this.unqualifiedFileCode = data["unqualifiedFileCode"];
            this.situation = data["situation"];
            this.note = data["note"];
            this.applyName = data["applyName"];
            if (data["handleUserList"] && data["handleUserList"].constructor === Array) {
                this.handleUserList = [];
                for (let item of data["handleUserList"])
                    this.handleUserList.push(FlowNodeUser.fromJS(item));
            }
            this.timeLimit = data["timeLimit"];
            this.currentHandleUserName = data["currentHandleUserName"];
            this.currentHandleUserCode = data["currentHandleUserCode"];
            this.currentNodeId = data["currentNodeId"];
            this.currentNodeName = data["currentNodeName"];
            this.currentHandleOrgName = data["currentHandleOrgName"];
            this.currentHandleOrgCode = data["currentHandleOrgCode"];
            this.nodeAuditorRecordId = data["nodeAuditorRecordId"];
            this.workFlow_NodeRecord_Id = data["workFlow_NodeRecord_Id"];
            this.workFlow_Instance_Id = data["workFlow_Instance_Id"];
            this.workFlow_TemplateInfo_Id = data["workFlow_TemplateInfo_Id"];
            this.flowNo = data["flowNo"];
            this.area = data["area"];
        }
    }

    static fromJS(data: any): ReviewFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileCodePrefix"] = this.fileCodePrefix;
        data["projectId"] = this.projectId;
        data["flowId"] = this.flowId;
        data["constructOrg"] = this.constructOrg ? this.constructOrg.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        data["projectCode"] = this.projectCode;
        data["address"] = this.address;
        data["recordFileCode"] = this.recordFileCode;
        data["unqualifiedFileCode"] = this.unqualifiedFileCode;
        data["situation"] = this.situation;
        data["note"] = this.note;
        data["applyName"] = this.applyName;
        if (this.handleUserList && this.handleUserList.constructor === Array) {
            data["handleUserList"] = [];
            for (let item of this.handleUserList)
                data["handleUserList"].push(item.toJSON());
        }
        data["timeLimit"] = this.timeLimit;
        data["currentHandleUserName"] = this.currentHandleUserName;
        data["currentHandleUserCode"] = this.currentHandleUserCode;
        data["currentNodeId"] = this.currentNodeId;
        data["currentNodeName"] = this.currentNodeName;
        data["currentHandleOrgName"] = this.currentHandleOrgName;
        data["currentHandleOrgCode"] = this.currentHandleOrgCode;
        data["nodeAuditorRecordId"] = this.nodeAuditorRecordId;
        data["workFlow_NodeRecord_Id"] = this.workFlow_NodeRecord_Id;
        data["workFlow_Instance_Id"] = this.workFlow_Instance_Id;
        data["workFlow_TemplateInfo_Id"] = this.workFlow_TemplateInfo_Id;
        data["flowNo"] = this.flowNo;
        data["area"] = this.area;
        return data; 
    }

    clone(): ReviewFormDto {
        const json = this.toJSON();
        let result = new ReviewFormDto();
        result.init(json);
        return result;
    }
}

export interface IReviewFormDto {
    fileCodePrefix: string | undefined;
    projectId: number | undefined;
    flowId: number | undefined;
    constructOrg: ProjectCompany | undefined;
    projectName: string | undefined;
    projectCode: string | undefined;
    address: string | undefined;
    recordFileCode: string | undefined;
    unqualifiedFileCode: string | undefined;
    situation: string | undefined;
    note: string | undefined;
    applyName: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    timeLimit: number | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNo: string | undefined;
    area: string | undefined;
}

export class ProjectCompany implements IProjectCompany {
    projectId: number | undefined;
    orgType: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IProjectCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.orgType = data["orgType"];
            this.companyName = data["companyName"];
            this.qualifications = data["qualifications"];
            this.legalRepresentative = data["legalRepresentative"];
            this.legalRepresentativeNo = data["legalRepresentativeNo"];
            this.contactPerson = data["contactPerson"];
            this.contactNumber = data["contactNumber"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectCompany {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCompany();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["orgType"] = this.orgType;
        data["companyName"] = this.companyName;
        data["qualifications"] = this.qualifications;
        data["legalRepresentative"] = this.legalRepresentative;
        data["legalRepresentativeNo"] = this.legalRepresentativeNo;
        data["contactPerson"] = this.contactPerson;
        data["contactNumber"] = this.contactNumber;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProjectCompany {
        const json = this.toJSON();
        let result = new ProjectCompany();
        result.init(json);
        return result;
    }
}

export interface IProjectCompany {
    projectId: number | undefined;
    orgType: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ExamineFormDto implements IExamineFormDto {
    flowId: number | undefined;
    attachment: ProjectAttachment[] | undefined;
    isFinalFlow: boolean | undefined;
    isPass: boolean | undefined;
    isDisplay: boolean | undefined;
    opinion: string | undefined;
    describeList: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    fileCodePrefix: string | undefined;
    companyName: string | undefined;
    applyDateTime: moment.Moment | undefined;
    address: string | undefined;
    projectId: number | undefined;
    projectName: string | undefined;
    projectCode: string | undefined;
    recordNumber: string | undefined;
    acceptFileCode: string | undefined;
    drawingOrg: ProjectCompany | undefined;
    testingOrg: ProjectCompany | undefined;
    designOrg: ProjectCompany | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNodeUserInfo: FlowNodeUser | undefined;
    flowNodeItems: FlowNodeItem[] | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    regionAndCountyName: string | undefined;
    area: string | undefined;
    opinionFileId: string | undefined;
    opinionFileUrl: string | undefined;

    constructor(data?: IExamineFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flowId = data["flowId"];
            if (data["attachment"] && data["attachment"].constructor === Array) {
                this.attachment = [];
                for (let item of data["attachment"])
                    this.attachment.push(ProjectAttachment.fromJS(item));
            }
            this.isFinalFlow = data["isFinalFlow"];
            this.isPass = data["isPass"];
            this.isDisplay = data["isDisplay"];
            this.opinion = data["opinion"];
            this.describeList = data["describeList"];
            this.currentHandleUserName = data["currentHandleUserName"];
            this.currentHandleUserCode = data["currentHandleUserCode"];
            if (data["handleUserList"] && data["handleUserList"].constructor === Array) {
                this.handleUserList = [];
                for (let item of data["handleUserList"])
                    this.handleUserList.push(FlowNodeUser.fromJS(item));
            }
            this.currentNodeId = data["currentNodeId"];
            this.currentNodeName = data["currentNodeName"];
            this.currentHandleOrgName = data["currentHandleOrgName"];
            this.currentHandleOrgCode = data["currentHandleOrgCode"];
            this.fileCodePrefix = data["fileCodePrefix"];
            this.companyName = data["companyName"];
            this.applyDateTime = data["applyDateTime"] ? moment(data["applyDateTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.projectId = data["projectId"];
            this.projectName = data["projectName"];
            this.projectCode = data["projectCode"];
            this.recordNumber = data["recordNumber"];
            this.acceptFileCode = data["acceptFileCode"];
            this.drawingOrg = data["drawingOrg"] ? ProjectCompany.fromJS(data["drawingOrg"]) : <any>undefined;
            this.testingOrg = data["testingOrg"] ? ProjectCompany.fromJS(data["testingOrg"]) : <any>undefined;
            this.designOrg = data["designOrg"] ? ProjectCompany.fromJS(data["designOrg"]) : <any>undefined;
            this.nodeAuditorRecordId = data["nodeAuditorRecordId"];
            this.workFlow_NodeRecord_Id = data["workFlow_NodeRecord_Id"];
            this.workFlow_Instance_Id = data["workFlow_Instance_Id"];
            this.workFlow_TemplateInfo_Id = data["workFlow_TemplateInfo_Id"];
            this.flowNodeUserInfo = data["flowNodeUserInfo"] ? FlowNodeUser.fromJS(data["flowNodeUserInfo"]) : <any>undefined;
            if (data["flowNodeItems"] && data["flowNodeItems"].constructor === Array) {
                this.flowNodeItems = [];
                for (let item of data["flowNodeItems"])
                    this.flowNodeItems.push(FlowNodeItem.fromJS(item));
            }
            this.provinceName = data["provinceName"];
            this.cityName = data["cityName"];
            this.regionAndCountyName = data["regionAndCountyName"];
            this.area = data["area"];
            this.opinionFileId = data["opinionFileId"];
            this.opinionFileUrl = data["opinionFileUrl"];
        }
    }

    static fromJS(data: any): ExamineFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamineFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowId"] = this.flowId;
        if (this.attachment && this.attachment.constructor === Array) {
            data["attachment"] = [];
            for (let item of this.attachment)
                data["attachment"].push(item.toJSON());
        }
        data["isFinalFlow"] = this.isFinalFlow;
        data["isPass"] = this.isPass;
        data["isDisplay"] = this.isDisplay;
        data["opinion"] = this.opinion;
        data["describeList"] = this.describeList;
        data["currentHandleUserName"] = this.currentHandleUserName;
        data["currentHandleUserCode"] = this.currentHandleUserCode;
        if (this.handleUserList && this.handleUserList.constructor === Array) {
            data["handleUserList"] = [];
            for (let item of this.handleUserList)
                data["handleUserList"].push(item.toJSON());
        }
        data["currentNodeId"] = this.currentNodeId;
        data["currentNodeName"] = this.currentNodeName;
        data["currentHandleOrgName"] = this.currentHandleOrgName;
        data["currentHandleOrgCode"] = this.currentHandleOrgCode;
        data["fileCodePrefix"] = this.fileCodePrefix;
        data["companyName"] = this.companyName;
        data["applyDateTime"] = this.applyDateTime ? this.applyDateTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["projectCode"] = this.projectCode;
        data["recordNumber"] = this.recordNumber;
        data["acceptFileCode"] = this.acceptFileCode;
        data["drawingOrg"] = this.drawingOrg ? this.drawingOrg.toJSON() : <any>undefined;
        data["testingOrg"] = this.testingOrg ? this.testingOrg.toJSON() : <any>undefined;
        data["designOrg"] = this.designOrg ? this.designOrg.toJSON() : <any>undefined;
        data["nodeAuditorRecordId"] = this.nodeAuditorRecordId;
        data["workFlow_NodeRecord_Id"] = this.workFlow_NodeRecord_Id;
        data["workFlow_Instance_Id"] = this.workFlow_Instance_Id;
        data["workFlow_TemplateInfo_Id"] = this.workFlow_TemplateInfo_Id;
        data["flowNodeUserInfo"] = this.flowNodeUserInfo ? this.flowNodeUserInfo.toJSON() : <any>undefined;
        if (this.flowNodeItems && this.flowNodeItems.constructor === Array) {
            data["flowNodeItems"] = [];
            for (let item of this.flowNodeItems)
                data["flowNodeItems"].push(item.toJSON());
        }
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["regionAndCountyName"] = this.regionAndCountyName;
        data["area"] = this.area;
        data["opinionFileId"] = this.opinionFileId;
        data["opinionFileUrl"] = this.opinionFileUrl;
        return data; 
    }

    clone(): ExamineFormDto {
        const json = this.toJSON();
        let result = new ExamineFormDto();
        result.init(json);
        return result;
    }
}

export interface IExamineFormDto {
    flowId: number | undefined;
    attachment: ProjectAttachment[] | undefined;
    isFinalFlow: boolean | undefined;
    isPass: boolean | undefined;
    isDisplay: boolean | undefined;
    opinion: string | undefined;
    describeList: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    currentHandleOrgName: string | undefined;
    currentHandleOrgCode: string | undefined;
    fileCodePrefix: string | undefined;
    companyName: string | undefined;
    applyDateTime: moment.Moment | undefined;
    address: string | undefined;
    projectId: number | undefined;
    projectName: string | undefined;
    projectCode: string | undefined;
    recordNumber: string | undefined;
    acceptFileCode: string | undefined;
    drawingOrg: ProjectCompany | undefined;
    testingOrg: ProjectCompany | undefined;
    designOrg: ProjectCompany | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    flowNodeUserInfo: FlowNodeUser | undefined;
    flowNodeItems: FlowNodeItem[] | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    regionAndCountyName: string | undefined;
    area: string | undefined;
    opinionFileId: string | undefined;
    opinionFileUrl: string | undefined;
}

export class ProjectAttachment implements IProjectAttachment {
    projectId: number | undefined;
    attachmentName: string | undefined;
    attachmentType: string | undefined;
    fileUrl: string | undefined;
    note: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    fileCount: number | undefined;
    isPass: boolean | undefined;
    fileNo: number | undefined;
    flieCode: string | undefined;
    flowNode: string | undefined;
    recordId: number | undefined;
    flowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IProjectAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.attachmentName = data["attachmentName"];
            this.attachmentType = data["attachmentType"];
            this.fileUrl = data["fileUrl"];
            this.note = data["note"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.fileCount = data["fileCount"];
            this.isPass = data["isPass"];
            this.fileNo = data["fileNo"];
            this.flieCode = data["flieCode"];
            this.flowNode = data["flowNode"];
            this.recordId = data["recordId"];
            this.flowId = data["flowId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["attachmentName"] = this.attachmentName;
        data["attachmentType"] = this.attachmentType;
        data["fileUrl"] = this.fileUrl;
        data["note"] = this.note;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["fileCount"] = this.fileCount;
        data["isPass"] = this.isPass;
        data["fileNo"] = this.fileNo;
        data["flieCode"] = this.flieCode;
        data["flowNode"] = this.flowNode;
        data["recordId"] = this.recordId;
        data["flowId"] = this.flowId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProjectAttachment {
        const json = this.toJSON();
        let result = new ProjectAttachment();
        result.init(json);
        return result;
    }
}

export interface IProjectAttachment {
    projectId: number | undefined;
    attachmentName: string | undefined;
    attachmentType: string | undefined;
    fileUrl: string | undefined;
    note: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    fileCount: number | undefined;
    isPass: boolean | undefined;
    fileNo: number | undefined;
    flieCode: string | undefined;
    flowNode: string | undefined;
    recordId: number | undefined;
    flowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class FlowFormQueryDto implements IFlowFormQueryDto {
    flowType: number | undefined;
    projectId: number | undefined;
    flowId: number | undefined;

    constructor(data?: IFlowFormQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flowType = data["flowType"];
            this.projectId = data["projectId"];
            this.flowId = data["flowId"];
        }
    }

    static fromJS(data: any): FlowFormQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowFormQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowType"] = this.flowType;
        data["projectId"] = this.projectId;
        data["flowId"] = this.flowId;
        return data; 
    }

    clone(): FlowFormQueryDto {
        const json = this.toJSON();
        let result = new FlowFormQueryDto();
        result.init(json);
        return result;
    }
}

export interface IFlowFormQueryDto {
    flowType: number | undefined;
    projectId: number | undefined;
    flowId: number | undefined;
}

export class FlowFormAllDataDto implements IFlowFormAllDataDto {
    specialNatures: SpecialNatureItem[] | undefined;
    natures: ArchitecturalInNature[] | undefined;
    formJson: string | undefined;
    projectId: number | undefined;
    projectTypeStatu: number | undefined;

    constructor(data?: IFlowFormAllDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["specialNatures"] && data["specialNatures"].constructor === Array) {
                this.specialNatures = [];
                for (let item of data["specialNatures"])
                    this.specialNatures.push(SpecialNatureItem.fromJS(item));
            }
            if (data["natures"] && data["natures"].constructor === Array) {
                this.natures = [];
                for (let item of data["natures"])
                    this.natures.push(ArchitecturalInNature.fromJS(item));
            }
            this.formJson = data["formJson"];
            this.projectId = data["projectId"];
            this.projectTypeStatu = data["projectTypeStatu"];
        }
    }

    static fromJS(data: any): FlowFormAllDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowFormAllDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.specialNatures && this.specialNatures.constructor === Array) {
            data["specialNatures"] = [];
            for (let item of this.specialNatures)
                data["specialNatures"].push(item.toJSON());
        }
        if (this.natures && this.natures.constructor === Array) {
            data["natures"] = [];
            for (let item of this.natures)
                data["natures"].push(item.toJSON());
        }
        data["formJson"] = this.formJson;
        data["projectId"] = this.projectId;
        data["projectTypeStatu"] = this.projectTypeStatu;
        return data; 
    }

    clone(): FlowFormAllDataDto {
        const json = this.toJSON();
        let result = new FlowFormAllDataDto();
        result.init(json);
        return result;
    }
}

export interface IFlowFormAllDataDto {
    specialNatures: SpecialNatureItem[] | undefined;
    natures: ArchitecturalInNature[] | undefined;
    formJson: string | undefined;
    projectId: number | undefined;
    projectTypeStatu: number | undefined;
}

export class SpecialNatureItem implements ISpecialNatureItem {
    specialNatureTypeInfo: SpecialNatureType | undefined;
    nature: ArchitecturalInNature[] | undefined;

    constructor(data?: ISpecialNatureItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.specialNatureTypeInfo = data["specialNatureTypeInfo"] ? SpecialNatureType.fromJS(data["specialNatureTypeInfo"]) : <any>undefined;
            if (data["nature"] && data["nature"].constructor === Array) {
                this.nature = [];
                for (let item of data["nature"])
                    this.nature.push(ArchitecturalInNature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpecialNatureItem {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialNatureItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialNatureTypeInfo"] = this.specialNatureTypeInfo ? this.specialNatureTypeInfo.toJSON() : <any>undefined;
        if (this.nature && this.nature.constructor === Array) {
            data["nature"] = [];
            for (let item of this.nature)
                data["nature"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SpecialNatureItem {
        const json = this.toJSON();
        let result = new SpecialNatureItem();
        result.init(json);
        return result;
    }
}

export interface ISpecialNatureItem {
    specialNatureTypeInfo: SpecialNatureType | undefined;
    nature: ArchitecturalInNature[] | undefined;
}

export class ArchitecturalInNature implements IArchitecturalInNature {
    natureCode: string | undefined;
    natureName: string | undefined;
    displayOrder: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IArchitecturalInNature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.natureCode = data["natureCode"];
            this.natureName = data["natureName"];
            this.displayOrder = data["displayOrder"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ArchitecturalInNature {
        data = typeof data === 'object' ? data : {};
        let result = new ArchitecturalInNature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["natureCode"] = this.natureCode;
        data["natureName"] = this.natureName;
        data["displayOrder"] = this.displayOrder;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ArchitecturalInNature {
        const json = this.toJSON();
        let result = new ArchitecturalInNature();
        result.init(json);
        return result;
    }
}

export interface IArchitecturalInNature {
    natureCode: string | undefined;
    natureName: string | undefined;
    displayOrder: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SpecialNatureType implements ISpecialNatureType {
    describe: string | undefined;
    displayOrder: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISpecialNatureType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.describe = data["describe"];
            this.displayOrder = data["displayOrder"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SpecialNatureType {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialNatureType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["describe"] = this.describe;
        data["displayOrder"] = this.displayOrder;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SpecialNatureType {
        const json = this.toJSON();
        let result = new SpecialNatureType();
        result.init(json);
        return result;
    }
}

export interface ISpecialNatureType {
    describe: string | undefined;
    displayOrder: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class FlowFormDto implements IFlowFormDto {
    formJson: string | undefined;
    projectId: number | undefined;
    projectTypeStatu: number | undefined;

    constructor(data?: IFlowFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.formJson = data["formJson"];
            this.projectId = data["projectId"];
            this.projectTypeStatu = data["projectTypeStatu"];
        }
    }

    static fromJS(data: any): FlowFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formJson"] = this.formJson;
        data["projectId"] = this.projectId;
        data["projectTypeStatu"] = this.projectTypeStatu;
        return data; 
    }

    clone(): FlowFormDto {
        const json = this.toJSON();
        let result = new FlowFormDto();
        result.init(json);
        return result;
    }
}

export interface IFlowFormDto {
    formJson: string | undefined;
    projectId: number | undefined;
    projectTypeStatu: number | undefined;
}

export class FlowDataDto implements IFlowDataDto {
    projectId: number | undefined;
    flowId: number | undefined;
    formJson: string | undefined;
    projectFlowInfo: ProjectFlowDto | undefined;
    luckNo: number | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    fileCodePrefix: string | undefined;

    constructor(data?: IFlowDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.flowId = data["flowId"];
            this.formJson = data["formJson"];
            this.projectFlowInfo = data["projectFlowInfo"] ? ProjectFlowDto.fromJS(data["projectFlowInfo"]) : <any>undefined;
            this.luckNo = data["luckNo"];
            if (data["handleUserList"] && data["handleUserList"].constructor === Array) {
                this.handleUserList = [];
                for (let item of data["handleUserList"])
                    this.handleUserList.push(FlowNodeUser.fromJS(item));
            }
            this.fileCodePrefix = data["fileCodePrefix"];
        }
    }

    static fromJS(data: any): FlowDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["flowId"] = this.flowId;
        data["formJson"] = this.formJson;
        data["projectFlowInfo"] = this.projectFlowInfo ? this.projectFlowInfo.toJSON() : <any>undefined;
        data["luckNo"] = this.luckNo;
        if (this.handleUserList && this.handleUserList.constructor === Array) {
            data["handleUserList"] = [];
            for (let item of this.handleUserList)
                data["handleUserList"].push(item.toJSON());
        }
        data["fileCodePrefix"] = this.fileCodePrefix;
        return data; 
    }

    clone(): FlowDataDto {
        const json = this.toJSON();
        let result = new FlowDataDto();
        result.init(json);
        return result;
    }
}

export interface IFlowDataDto {
    projectId: number | undefined;
    flowId: number | undefined;
    formJson: string | undefined;
    projectFlowInfo: ProjectFlowDto | undefined;
    luckNo: number | undefined;
    handleUserList: FlowNodeUser[] | undefined;
    fileCodePrefix: string | undefined;
}

export class ProjectFlowDto implements IProjectFlowDto {
    timeLimit: number | undefined;
    projectId: number | undefined;
    flowPathType: number | undefined;
    flowNo: string | undefined;
    applyTime: moment.Moment | undefined;
    applyUserCode: string | undefined;
    applyName: string | undefined;
    status: number | undefined;
    endTime: moment.Moment | undefined;
    expireTime: moment.Moment | undefined;
    applyingForms: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    recordNumber: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    parentFlowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IProjectFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeLimit = data["timeLimit"];
            this.projectId = data["projectId"];
            this.flowPathType = data["flowPathType"];
            this.flowNo = data["flowNo"];
            this.applyTime = data["applyTime"] ? moment(data["applyTime"].toString()) : <any>undefined;
            this.applyUserCode = data["applyUserCode"];
            this.applyName = data["applyName"];
            this.status = data["status"];
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.expireTime = data["expireTime"] ? moment(data["expireTime"].toString()) : <any>undefined;
            this.applyingForms = data["applyingForms"];
            this.currentHandleUserName = data["currentHandleUserName"];
            this.currentHandleUserCode = data["currentHandleUserCode"];
            this.currentNodeId = data["currentNodeId"];
            this.currentNodeName = data["currentNodeName"];
            this.recordNumber = data["recordNumber"];
            this.nodeAuditorRecordId = data["nodeAuditorRecordId"];
            this.workFlow_NodeRecord_Id = data["workFlow_NodeRecord_Id"];
            this.workFlow_Instance_Id = data["workFlow_Instance_Id"];
            this.workFlow_TemplateInfo_Id = data["workFlow_TemplateInfo_Id"];
            this.parentFlowId = data["parentFlowId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeLimit"] = this.timeLimit;
        data["projectId"] = this.projectId;
        data["flowPathType"] = this.flowPathType;
        data["flowNo"] = this.flowNo;
        data["applyTime"] = this.applyTime ? this.applyTime.toISOString() : <any>undefined;
        data["applyUserCode"] = this.applyUserCode;
        data["applyName"] = this.applyName;
        data["status"] = this.status;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["applyingForms"] = this.applyingForms;
        data["currentHandleUserName"] = this.currentHandleUserName;
        data["currentHandleUserCode"] = this.currentHandleUserCode;
        data["currentNodeId"] = this.currentNodeId;
        data["currentNodeName"] = this.currentNodeName;
        data["recordNumber"] = this.recordNumber;
        data["nodeAuditorRecordId"] = this.nodeAuditorRecordId;
        data["workFlow_NodeRecord_Id"] = this.workFlow_NodeRecord_Id;
        data["workFlow_Instance_Id"] = this.workFlow_Instance_Id;
        data["workFlow_TemplateInfo_Id"] = this.workFlow_TemplateInfo_Id;
        data["parentFlowId"] = this.parentFlowId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProjectFlowDto {
        const json = this.toJSON();
        let result = new ProjectFlowDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowDto {
    timeLimit: number | undefined;
    projectId: number | undefined;
    flowPathType: number | undefined;
    flowNo: string | undefined;
    applyTime: moment.Moment | undefined;
    applyUserCode: string | undefined;
    applyName: string | undefined;
    status: number | undefined;
    endTime: moment.Moment | undefined;
    expireTime: moment.Moment | undefined;
    applyingForms: string | undefined;
    currentHandleUserName: string | undefined;
    currentHandleUserCode: string | undefined;
    currentNodeId: string | undefined;
    currentNodeName: string | undefined;
    recordNumber: string | undefined;
    nodeAuditorRecordId: number | undefined;
    workFlow_NodeRecord_Id: number | undefined;
    workFlow_Instance_Id: number | undefined;
    workFlow_TemplateInfo_Id: number | undefined;
    parentFlowId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserBaseDto implements IUserBaseDto {
    id: string | undefined;
    userName: string | undefined;
    userCode: string | undefined;
    orgCode: string | undefined;
    orgName: string | undefined;

    constructor(data?: IUserBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.userCode = data["userCode"];
            this.orgCode = data["orgCode"];
            this.orgName = data["orgName"];
        }
    }

    static fromJS(data: any): UserBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["userCode"] = this.userCode;
        data["orgCode"] = this.orgCode;
        data["orgName"] = this.orgName;
        return data; 
    }

    clone(): UserBaseDto {
        const json = this.toJSON();
        let result = new UserBaseDto();
        result.init(json);
        return result;
    }
}

export interface IUserBaseDto {
    id: string | undefined;
    userName: string | undefined;
    userCode: string | undefined;
    orgCode: string | undefined;
    orgName: string | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    guid: string | undefined;
    attachmentName: string | undefined;
    category: number | undefined;
    fileUrl: string | undefined;
    relationID: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    visitCount: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.guid = data["guid"];
            this.attachmentName = data["attachmentName"];
            this.category = data["category"];
            this.fileUrl = data["fileUrl"];
            this.relationID = data["relationID"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.visitCount = data["visitCount"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["attachmentName"] = this.attachmentName;
        data["category"] = this.category;
        data["fileUrl"] = this.fileUrl;
        data["relationID"] = this.relationID;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["visitCount"] = this.visitCount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AttachmentDto {
        const json = this.toJSON();
        let result = new AttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IAttachmentDto {
    guid: string | undefined;
    attachmentName: string | undefined;
    category: number | undefined;
    fileUrl: string | undefined;
    relationID: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    visitCount: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PageSize implements IPageSize {
    size: number | undefined;
    page: number | undefined;
    sort: string | undefined;
    isAsc: boolean | undefined;
    group: string | undefined;
    orderby: string | undefined;
    search: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    totalCount: number | undefined;

    constructor(data?: IPageSize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.size = data["size"];
            this.page = data["page"];
            this.sort = data["sort"];
            this.isAsc = data["isAsc"];
            this.group = data["group"];
            this.orderby = data["orderby"];
            this.search = data["search"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PageSize {
        data = typeof data === 'object' ? data : {};
        let result = new PageSize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["page"] = this.page;
        data["sort"] = this.sort;
        data["isAsc"] = this.isAsc;
        data["group"] = this.group;
        data["orderby"] = this.orderby;
        data["search"] = this.search;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PageSize {
        const json = this.toJSON();
        let result = new PageSize();
        result.init(json);
        return result;
    }
}

export interface IPageSize {
    size: number | undefined;
    page: number | undefined;
    sort: string | undefined;
    isAsc: boolean | undefined;
    group: string | undefined;
    orderby: string | undefined;
    search: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    totalCount: number | undefined;
}

export class PageModel implements IPageModel {
    totalCount: number | undefined;
    page: number | undefined;
    size: number | undefined;
    data: any | undefined;
    msg: string | undefined;
    isTrue: boolean | undefined;

    constructor(data?: IPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.page = data["page"];
            this.size = data["size"];
            this.data = data["data"];
            this.msg = data["msg"];
            this.isTrue = data["isTrue"];
        }
    }

    static fromJS(data: any): PageModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["size"] = this.size;
        data["data"] = this.data;
        data["msg"] = this.msg;
        data["isTrue"] = this.isTrue;
        return data; 
    }

    clone(): PageModel {
        const json = this.toJSON();
        let result = new PageModel();
        result.init(json);
        return result;
    }
}

export interface IPageModel {
    totalCount: number | undefined;
    page: number | undefined;
    size: number | undefined;
    data: any | undefined;
    msg: string | undefined;
    isTrue: boolean | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class EnumConfig implements IEnumConfig {
    enumName: string | undefined;
    enumType: string | undefined;
    parentTypeId: number | undefined;
    displayOrder: number | undefined;
    isNote: boolean | undefined;
    isDisable: boolean | undefined;
    value: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IEnumConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enumName = data["enumName"];
            this.enumType = data["enumType"];
            this.parentTypeId = data["parentTypeId"];
            this.displayOrder = data["displayOrder"];
            this.isNote = data["isNote"];
            this.isDisable = data["isDisable"];
            this.value = data["value"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EnumConfig {
        data = typeof data === 'object' ? data : {};
        let result = new EnumConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumName"] = this.enumName;
        data["enumType"] = this.enumType;
        data["parentTypeId"] = this.parentTypeId;
        data["displayOrder"] = this.displayOrder;
        data["isNote"] = this.isNote;
        data["isDisable"] = this.isDisable;
        data["value"] = this.value;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EnumConfig {
        const json = this.toJSON();
        let result = new EnumConfig();
        result.init(json);
        return result;
    }
}

export interface IEnumConfig {
    enumName: string | undefined;
    enumType: string | undefined;
    parentTypeId: number | undefined;
    displayOrder: number | undefined;
    isNote: boolean | undefined;
    isDisable: boolean | undefined;
    value: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SignForDto implements ISignForDto {
    name: string | undefined;
    phoneNumber: string | undefined;
    flowId: number | undefined;

    constructor(data?: ISignForDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.phoneNumber = data["phoneNumber"];
            this.flowId = data["flowId"];
        }
    }

    static fromJS(data: any): SignForDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignForDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["flowId"] = this.flowId;
        return data; 
    }

    clone(): SignForDto {
        const json = this.toJSON();
        let result = new SignForDto();
        result.init(json);
        return result;
    }
}

export interface ISignForDto {
    name: string | undefined;
    phoneNumber: string | undefined;
    flowId: number | undefined;
}

export class RegulationDetailsViewModel implements IRegulationDetailsViewModel {
    content: string | undefined;
    guid: string | undefined;
    regulationTypeId: string | undefined;
    id: number | undefined;
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationType: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    visitCount: number | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IRegulationDetailsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.guid = data["guid"];
            this.regulationTypeId = data["regulationTypeId"];
            this.id = data["id"];
            this.regulationCode = data["regulationCode"];
            this.title = data["title"];
            this.issueOrg = data["issueOrg"];
            this.regulationType = data["regulationType"];
            this.issueDate = data["issueDate"] ? moment(data["issueDate"].toString()) : <any>undefined;
            this.contentUrl = data["contentUrl"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.visitCount = data["visitCount"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RegulationDetailsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegulationDetailsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["guid"] = this.guid;
        data["regulationTypeId"] = this.regulationTypeId;
        data["id"] = this.id;
        data["regulationCode"] = this.regulationCode;
        data["title"] = this.title;
        data["issueOrg"] = this.issueOrg;
        data["regulationType"] = this.regulationType;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["contentUrl"] = this.contentUrl;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["visitCount"] = this.visitCount;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RegulationDetailsViewModel {
        const json = this.toJSON();
        let result = new RegulationDetailsViewModel();
        result.init(json);
        return result;
    }
}

export interface IRegulationDetailsViewModel {
    content: string | undefined;
    guid: string | undefined;
    regulationTypeId: string | undefined;
    id: number | undefined;
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationType: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    visitCount: number | undefined;
    creationTime: moment.Moment | undefined;
}

export class NoticeViewModel implements INoticeViewModel {
    guid: string | undefined;
    content: string | undefined;
    noticeType: string | undefined;
    title: string | undefined;
    contentUrl: string | undefined;
    noticeTypeId: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    brief: string | undefined;
    visitCount: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: INoticeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.guid = data["guid"];
            this.content = data["content"];
            this.noticeType = data["noticeType"];
            this.title = data["title"];
            this.contentUrl = data["contentUrl"];
            this.noticeTypeId = data["noticeTypeId"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.brief = data["brief"];
            this.visitCount = data["visitCount"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NoticeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["content"] = this.content;
        data["noticeType"] = this.noticeType;
        data["title"] = this.title;
        data["contentUrl"] = this.contentUrl;
        data["noticeTypeId"] = this.noticeTypeId;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["brief"] = this.brief;
        data["visitCount"] = this.visitCount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NoticeViewModel {
        const json = this.toJSON();
        let result = new NoticeViewModel();
        result.init(json);
        return result;
    }
}

export interface INoticeViewModel {
    guid: string | undefined;
    content: string | undefined;
    noticeType: string | undefined;
    title: string | undefined;
    contentUrl: string | undefined;
    noticeTypeId: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    brief: string | undefined;
    visitCount: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Condition implements ICondition {
    flowType: number | undefined;
    cityId: number | undefined;
    cityName: string | undefined;
    regionId: number | undefined;
    regionName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    size: number | undefined;
    page: number | undefined;
    isAsc: boolean | undefined;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flowType = data["flowType"];
            this.cityId = data["cityId"];
            this.cityName = data["cityName"];
            this.regionId = data["regionId"];
            this.regionName = data["regionName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.size = data["size"];
            this.page = data["page"];
            this.isAsc = data["isAsc"];
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        let result = new Condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowType"] = this.flowType;
        data["cityId"] = this.cityId;
        data["cityName"] = this.cityName;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["size"] = this.size;
        data["page"] = this.page;
        data["isAsc"] = this.isAsc;
        return data; 
    }

    clone(): Condition {
        const json = this.toJSON();
        let result = new Condition();
        result.init(json);
        return result;
    }
}

export interface ICondition {
    flowType: number | undefined;
    cityId: number | undefined;
    cityName: string | undefined;
    regionId: number | undefined;
    regionName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    size: number | undefined;
    page: number | undefined;
    isAsc: boolean | undefined;
}

export class AllOptions implements IAllOptions {
    archUnit: string | undefined;
    fzr: string | undefined;
    arcPhone: string | undefined;
    proName: string | undefined;
    contract: string | undefined;
    proPhone: string | undefined;
    proAddress: string | undefined;
    planStartTime: moment.Moment | undefined;
    planFinishTime: moment.Moment | undefined;
    type: string | undefined;
    units: Unit[] | undefined;
    permitCode: string | undefined;
    examCode: string | undefined;
    useProperties: string | undefined;
    archs: Arch[] | undefined;
    arch2s: Arch2[] | undefined;
    pots: Pot[] | undefined;
    yards: Yard[] | undefined;
    archWarm: ArchWarm | undefined;
    archUnitOption: string | undefined;
    designUnitOption: string | undefined;
    workingUnitOption: string | undefined;
    professUnit: string | undefined;
    projCheckUnit: string | undefined;
    fireCheckUnit: string | undefined;
    sysLists: FireControlSys[] | undefined;
    decorationPro: Decoration | undefined;
    fireControl: string | undefined;
    extra1: string | undefined;
    extra2: string | undefined;
    materialProvide: string | undefined;
    companyAdv: string | undefined;
    designCheckCode: string | undefined;
    checkDateStr: string | undefined;
    checkReportCode: string | undefined;

    constructor(data?: IAllOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archUnit = data["archUnit"];
            this.fzr = data["fzr"];
            this.arcPhone = data["arcPhone"];
            this.proName = data["proName"];
            this.contract = data["contract"];
            this.proPhone = data["proPhone"];
            this.proAddress = data["proAddress"];
            this.planStartTime = data["planStartTime"] ? moment(data["planStartTime"].toString()) : <any>undefined;
            this.planFinishTime = data["planFinishTime"] ? moment(data["planFinishTime"].toString()) : <any>undefined;
            this.type = data["type"];
            if (data["units"] && data["units"].constructor === Array) {
                this.units = [];
                for (let item of data["units"])
                    this.units.push(Unit.fromJS(item));
            }
            this.permitCode = data["permitCode"];
            this.examCode = data["examCode"];
            this.useProperties = data["useProperties"];
            if (data["archs"] && data["archs"].constructor === Array) {
                this.archs = [];
                for (let item of data["archs"])
                    this.archs.push(Arch.fromJS(item));
            }
            if (data["arch2s"] && data["arch2s"].constructor === Array) {
                this.arch2s = [];
                for (let item of data["arch2s"])
                    this.arch2s.push(Arch2.fromJS(item));
            }
            if (data["pots"] && data["pots"].constructor === Array) {
                this.pots = [];
                for (let item of data["pots"])
                    this.pots.push(Pot.fromJS(item));
            }
            if (data["yards"] && data["yards"].constructor === Array) {
                this.yards = [];
                for (let item of data["yards"])
                    this.yards.push(Yard.fromJS(item));
            }
            this.archWarm = data["archWarm"] ? ArchWarm.fromJS(data["archWarm"]) : <any>undefined;
            this.archUnitOption = data["archUnitOption"];
            this.designUnitOption = data["designUnitOption"];
            this.workingUnitOption = data["workingUnitOption"];
            this.professUnit = data["professUnit"];
            this.projCheckUnit = data["projCheckUnit"];
            this.fireCheckUnit = data["fireCheckUnit"];
            if (data["sysLists"] && data["sysLists"].constructor === Array) {
                this.sysLists = [];
                for (let item of data["sysLists"])
                    this.sysLists.push(FireControlSys.fromJS(item));
            }
            this.decorationPro = data["decorationPro"] ? Decoration.fromJS(data["decorationPro"]) : <any>undefined;
            this.fireControl = data["fireControl"];
            this.extra1 = data["extra1"];
            this.extra2 = data["extra2"];
            this.materialProvide = data["materialProvide"];
            this.companyAdv = data["companyAdv"];
            this.designCheckCode = data["designCheckCode"];
            this.checkDateStr = data["checkDateStr"];
            this.checkReportCode = data["checkReportCode"];
        }
    }

    static fromJS(data: any): AllOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AllOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archUnit"] = this.archUnit;
        data["fzr"] = this.fzr;
        data["arcPhone"] = this.arcPhone;
        data["proName"] = this.proName;
        data["contract"] = this.contract;
        data["proPhone"] = this.proPhone;
        data["proAddress"] = this.proAddress;
        data["planStartTime"] = this.planStartTime ? this.planStartTime.toISOString() : <any>undefined;
        data["planFinishTime"] = this.planFinishTime ? this.planFinishTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        if (this.units && this.units.constructor === Array) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        data["permitCode"] = this.permitCode;
        data["examCode"] = this.examCode;
        data["useProperties"] = this.useProperties;
        if (this.archs && this.archs.constructor === Array) {
            data["archs"] = [];
            for (let item of this.archs)
                data["archs"].push(item.toJSON());
        }
        if (this.arch2s && this.arch2s.constructor === Array) {
            data["arch2s"] = [];
            for (let item of this.arch2s)
                data["arch2s"].push(item.toJSON());
        }
        if (this.pots && this.pots.constructor === Array) {
            data["pots"] = [];
            for (let item of this.pots)
                data["pots"].push(item.toJSON());
        }
        if (this.yards && this.yards.constructor === Array) {
            data["yards"] = [];
            for (let item of this.yards)
                data["yards"].push(item.toJSON());
        }
        data["archWarm"] = this.archWarm ? this.archWarm.toJSON() : <any>undefined;
        data["archUnitOption"] = this.archUnitOption;
        data["designUnitOption"] = this.designUnitOption;
        data["workingUnitOption"] = this.workingUnitOption;
        data["professUnit"] = this.professUnit;
        data["projCheckUnit"] = this.projCheckUnit;
        data["fireCheckUnit"] = this.fireCheckUnit;
        if (this.sysLists && this.sysLists.constructor === Array) {
            data["sysLists"] = [];
            for (let item of this.sysLists)
                data["sysLists"].push(item.toJSON());
        }
        data["decorationPro"] = this.decorationPro ? this.decorationPro.toJSON() : <any>undefined;
        data["fireControl"] = this.fireControl;
        data["extra1"] = this.extra1;
        data["extra2"] = this.extra2;
        data["materialProvide"] = this.materialProvide;
        data["companyAdv"] = this.companyAdv;
        data["designCheckCode"] = this.designCheckCode;
        data["checkDateStr"] = this.checkDateStr;
        data["checkReportCode"] = this.checkReportCode;
        return data; 
    }

    clone(): AllOptions {
        const json = this.toJSON();
        let result = new AllOptions();
        result.init(json);
        return result;
    }
}

export interface IAllOptions {
    archUnit: string | undefined;
    fzr: string | undefined;
    arcPhone: string | undefined;
    proName: string | undefined;
    contract: string | undefined;
    proPhone: string | undefined;
    proAddress: string | undefined;
    planStartTime: moment.Moment | undefined;
    planFinishTime: moment.Moment | undefined;
    type: string | undefined;
    units: Unit[] | undefined;
    permitCode: string | undefined;
    examCode: string | undefined;
    useProperties: string | undefined;
    archs: Arch[] | undefined;
    arch2s: Arch2[] | undefined;
    pots: Pot[] | undefined;
    yards: Yard[] | undefined;
    archWarm: ArchWarm | undefined;
    archUnitOption: string | undefined;
    designUnitOption: string | undefined;
    workingUnitOption: string | undefined;
    professUnit: string | undefined;
    projCheckUnit: string | undefined;
    fireCheckUnit: string | undefined;
    sysLists: FireControlSys[] | undefined;
    decorationPro: Decoration | undefined;
    fireControl: string | undefined;
    extra1: string | undefined;
    extra2: string | undefined;
    materialProvide: string | undefined;
    companyAdv: string | undefined;
    designCheckCode: string | undefined;
    checkDateStr: string | undefined;
    checkReportCode: string | undefined;
}

export class Unit implements IUnit {
    unitType: string | undefined;
    unitName: string | undefined;
    degree: string | undefined;
    fzr: string | undefined;
    lxr: string | undefined;
    phone: string | undefined;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitType = data["unitType"];
            this.unitName = data["unitName"];
            this.degree = data["degree"];
            this.fzr = data["fzr"];
            this.lxr = data["lxr"];
            this.phone = data["phone"];
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitType"] = this.unitType;
        data["unitName"] = this.unitName;
        data["degree"] = this.degree;
        data["fzr"] = this.fzr;
        data["lxr"] = this.lxr;
        data["phone"] = this.phone;
        return data; 
    }

    clone(): Unit {
        const json = this.toJSON();
        let result = new Unit();
        result.init(json);
        return result;
    }
}

export interface IUnit {
    unitType: string | undefined;
    unitName: string | undefined;
    degree: string | undefined;
    fzr: string | undefined;
    lxr: string | undefined;
    phone: string | undefined;
}

export class Arch implements IArch {
    archName: string | undefined;
    struType: string | undefined;
    fireDegree: string | undefined;
    floorAbove: number | undefined;
    floorUnder: number | undefined;
    height: number | undefined;
    area: number | undefined;
    areaAbove: number | undefined;
    areaUnder: number | undefined;

    constructor(data?: IArch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archName = data["archName"];
            this.struType = data["struType"];
            this.fireDegree = data["fireDegree"];
            this.floorAbove = data["floorAbove"];
            this.floorUnder = data["floorUnder"];
            this.height = data["height"];
            this.area = data["area"];
            this.areaAbove = data["areaAbove"];
            this.areaUnder = data["areaUnder"];
        }
    }

    static fromJS(data: any): Arch {
        data = typeof data === 'object' ? data : {};
        let result = new Arch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archName"] = this.archName;
        data["struType"] = this.struType;
        data["fireDegree"] = this.fireDegree;
        data["floorAbove"] = this.floorAbove;
        data["floorUnder"] = this.floorUnder;
        data["height"] = this.height;
        data["area"] = this.area;
        data["areaAbove"] = this.areaAbove;
        data["areaUnder"] = this.areaUnder;
        return data; 
    }

    clone(): Arch {
        const json = this.toJSON();
        let result = new Arch();
        result.init(json);
        return result;
    }
}

export interface IArch {
    archName: string | undefined;
    struType: string | undefined;
    fireDegree: string | undefined;
    floorAbove: number | undefined;
    floorUnder: number | undefined;
    height: number | undefined;
    area: number | undefined;
    areaAbove: number | undefined;
    areaUnder: number | undefined;
}

export class Arch2 implements IArch2 {
    archName: string | undefined;
    struct: string | undefined;
    fireDegree: string | undefined;
    height: number | undefined;
    floorCount: number | undefined;
    area: number | undefined;
    dangerType: string | undefined;

    constructor(data?: IArch2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archName = data["archName"];
            this.struct = data["struct"];
            this.fireDegree = data["fireDegree"];
            this.height = data["height"];
            this.floorCount = data["floorCount"];
            this.area = data["area"];
            this.dangerType = data["dangerType"];
        }
    }

    static fromJS(data: any): Arch2 {
        data = typeof data === 'object' ? data : {};
        let result = new Arch2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archName"] = this.archName;
        data["struct"] = this.struct;
        data["fireDegree"] = this.fireDegree;
        data["height"] = this.height;
        data["floorCount"] = this.floorCount;
        data["area"] = this.area;
        data["dangerType"] = this.dangerType;
        return data; 
    }

    clone(): Arch2 {
        const json = this.toJSON();
        let result = new Arch2();
        result.init(json);
        return result;
    }
}

export interface IArch2 {
    archName: string | undefined;
    struct: string | undefined;
    fireDegree: string | undefined;
    height: number | undefined;
    floorCount: number | undefined;
    area: number | undefined;
    dangerType: string | undefined;
}

export class Pot implements IPot {
    locationCfg: string | undefined;
    volume: number | undefined;
    shapeCfg: string | undefined;
    storeWay: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    potMaterial: string | undefined;
    pressure: string | undefined;
    temperature: string | undefined;

    constructor(data?: IPot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationCfg = data["locationCfg"];
            this.volume = data["volume"];
            this.shapeCfg = data["shapeCfg"];
            this.storeWay = data["storeWay"];
            this.storeName = data["storeName"];
            this.storeType = data["storeType"];
            this.potMaterial = data["potMaterial"];
            this.pressure = data["pressure"];
            this.temperature = data["temperature"];
        }
    }

    static fromJS(data: any): Pot {
        data = typeof data === 'object' ? data : {};
        let result = new Pot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCfg"] = this.locationCfg;
        data["volume"] = this.volume;
        data["shapeCfg"] = this.shapeCfg;
        data["storeWay"] = this.storeWay;
        data["storeName"] = this.storeName;
        data["storeType"] = this.storeType;
        data["potMaterial"] = this.potMaterial;
        data["pressure"] = this.pressure;
        data["temperature"] = this.temperature;
        return data; 
    }

    clone(): Pot {
        const json = this.toJSON();
        let result = new Pot();
        result.init(json);
        return result;
    }
}

export interface IPot {
    locationCfg: string | undefined;
    volume: number | undefined;
    shapeCfg: string | undefined;
    storeWay: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    potMaterial: string | undefined;
    pressure: string | undefined;
    temperature: string | undefined;
}

export class Yard implements IYard {
    reserves: number | undefined;
    storeName: string | undefined;

    constructor(data?: IYard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reserves = data["reserves"];
            this.storeName = data["storeName"];
        }
    }

    static fromJS(data: any): Yard {
        data = typeof data === 'object' ? data : {};
        let result = new Yard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reserves"] = this.reserves;
        data["storeName"] = this.storeName;
        return data; 
    }

    clone(): Yard {
        const json = this.toJSON();
        let result = new Yard();
        result.init(json);
        return result;
    }
}

export interface IYard {
    reserves: number | undefined;
    storeName: string | undefined;
}

export class ArchWarm implements IArchWarm {
    materialType: string | undefined;
    layersNum: number | undefined;
    useWay: string | undefined;
    beforePurpose: string | undefined;

    constructor(data?: IArchWarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialType = data["materialType"];
            this.layersNum = data["layersNum"];
            this.useWay = data["useWay"];
            this.beforePurpose = data["beforePurpose"];
        }
    }

    static fromJS(data: any): ArchWarm {
        data = typeof data === 'object' ? data : {};
        let result = new ArchWarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialType"] = this.materialType;
        data["layersNum"] = this.layersNum;
        data["useWay"] = this.useWay;
        data["beforePurpose"] = this.beforePurpose;
        return data; 
    }

    clone(): ArchWarm {
        const json = this.toJSON();
        let result = new ArchWarm();
        result.init(json);
        return result;
    }
}

export interface IArchWarm {
    materialType: string | undefined;
    layersNum: number | undefined;
    useWay: string | undefined;
    beforePurpose: string | undefined;
}

export class FireControlSys implements IFireControlSys {
    fireControlType: string | undefined;
    places: string | undefined;
    type: string | undefined;

    constructor(data?: IFireControlSys) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fireControlType = data["fireControlType"];
            this.places = data["places"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): FireControlSys {
        data = typeof data === 'object' ? data : {};
        let result = new FireControlSys();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fireControlType"] = this.fireControlType;
        data["places"] = this.places;
        data["type"] = this.type;
        return data; 
    }

    clone(): FireControlSys {
        const json = this.toJSON();
        let result = new FireControlSys();
        result.init(json);
        return result;
    }
}

export interface IFireControlSys {
    fireControlType: string | undefined;
    places: string | undefined;
    type: string | undefined;
}

export class Decoration implements IDecoration {
    fitPosition: string | undefined;
    decorationArea: number | undefined;
    decorationFloor: number | undefined;
    useWay: string | undefined;
    beforePurpose: string | undefined;

    constructor(data?: IDecoration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fitPosition = data["fitPosition"];
            this.decorationArea = data["decorationArea"];
            this.decorationFloor = data["decorationFloor"];
            this.useWay = data["useWay"];
            this.beforePurpose = data["beforePurpose"];
        }
    }

    static fromJS(data: any): Decoration {
        data = typeof data === 'object' ? data : {};
        let result = new Decoration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fitPosition"] = this.fitPosition;
        data["decorationArea"] = this.decorationArea;
        data["decorationFloor"] = this.decorationFloor;
        data["useWay"] = this.useWay;
        data["beforePurpose"] = this.beforePurpose;
        return data; 
    }

    clone(): Decoration {
        const json = this.toJSON();
        let result = new Decoration();
        result.init(json);
        return result;
    }
}

export interface IDecoration {
    fitPosition: string | undefined;
    decorationArea: number | undefined;
    decorationFloor: number | undefined;
    useWay: string | undefined;
    beforePurpose: string | undefined;
}

export class FileResultDto implements IFileResultDto {
    fileName: string | undefined;
    fileUrl: string | undefined;

    constructor(data?: IFileResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileUrl = data["fileUrl"];
        }
    }

    static fromJS(data: any): FileResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileUrl"] = this.fileUrl;
        return data; 
    }

    clone(): FileResultDto {
        const json = this.toJSON();
        let result = new FileResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileResultDto {
    fileName: string | undefined;
    fileUrl: string | undefined;
}

export class EnterpriseDto implements IEnterpriseDto {
    name: string | undefined;
    leader: string | undefined;
    leaderPhone: string | undefined;
    contact: string | undefined;
    contactPhone: string | undefined;
    qualificationLevel: string | undefined;

    constructor(data?: IEnterpriseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.leader = data["leader"];
            this.leaderPhone = data["leaderPhone"];
            this.contact = data["contact"];
            this.contactPhone = data["contactPhone"];
            this.qualificationLevel = data["qualificationLevel"];
        }
    }

    static fromJS(data: any): EnterpriseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["leader"] = this.leader;
        data["leaderPhone"] = this.leaderPhone;
        data["contact"] = this.contact;
        data["contactPhone"] = this.contactPhone;
        data["qualificationLevel"] = this.qualificationLevel;
        return data; 
    }

    clone(): EnterpriseDto {
        const json = this.toJSON();
        let result = new EnterpriseDto();
        result.init(json);
        return result;
    }
}

export interface IEnterpriseDto {
    name: string | undefined;
    leader: string | undefined;
    leaderPhone: string | undefined;
    contact: string | undefined;
    contactPhone: string | undefined;
    qualificationLevel: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    clientId: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    clientId: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: string | undefined;
}

export class UserCacheDto implements IUserCacheDto {
    merchantId: string | undefined;
    merchantName: string | undefined;
    id: string | undefined;
    head: string | undefined;
    eid: string | undefined;
    eName: string | undefined;
    mobile: string | undefined;
    organizationsId: string | undefined;
    organizationsName: string | undefined;
    sex: UserCacheDtoSex | undefined;
    roleId: string | undefined;
    roleName: string | undefined;
    isLocked: boolean | undefined;
    lockBeginTime: moment.Moment | undefined;
    lockEndTime: moment.Moment | undefined;
    registerTime: moment.Moment | undefined;
    currentLoginIp: string | undefined;
    currentLoginTime: moment.Moment | undefined;
    lastLoginIp: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    visibilityOrganizationsIds: string[] | undefined;
    positionIds: string[] | undefined;
    creatorId: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierId: string | undefined;
    lastModificationTime: moment.Moment | undefined;

    constructor(data?: IUserCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.merchantId = data["merchantId"];
            this.merchantName = data["merchantName"];
            this.id = data["id"];
            this.head = data["head"];
            this.eid = data["eid"];
            this.eName = data["eName"];
            this.mobile = data["mobile"];
            this.organizationsId = data["organizationsId"];
            this.organizationsName = data["organizationsName"];
            this.sex = data["sex"];
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.isLocked = data["isLocked"];
            this.lockBeginTime = data["lockBeginTime"] ? moment(data["lockBeginTime"].toString()) : <any>undefined;
            this.lockEndTime = data["lockEndTime"] ? moment(data["lockEndTime"].toString()) : <any>undefined;
            this.registerTime = data["registerTime"] ? moment(data["registerTime"].toString()) : <any>undefined;
            this.currentLoginIp = data["currentLoginIp"];
            this.currentLoginTime = data["currentLoginTime"] ? moment(data["currentLoginTime"].toString()) : <any>undefined;
            this.lastLoginIp = data["lastLoginIp"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            if (data["visibilityOrganizationsIds"] && data["visibilityOrganizationsIds"].constructor === Array) {
                this.visibilityOrganizationsIds = [];
                for (let item of data["visibilityOrganizationsIds"])
                    this.visibilityOrganizationsIds.push(item);
            }
            if (data["positionIds"] && data["positionIds"].constructor === Array) {
                this.positionIds = [];
                for (let item of data["positionIds"])
                    this.positionIds.push(item);
            }
            this.creatorId = data["creatorId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.lastModifierId = data["lastModifierId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId;
        data["merchantName"] = this.merchantName;
        data["id"] = this.id;
        data["head"] = this.head;
        data["eid"] = this.eid;
        data["eName"] = this.eName;
        data["mobile"] = this.mobile;
        data["organizationsId"] = this.organizationsId;
        data["organizationsName"] = this.organizationsName;
        data["sex"] = this.sex;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["isLocked"] = this.isLocked;
        data["lockBeginTime"] = this.lockBeginTime ? this.lockBeginTime.toISOString() : <any>undefined;
        data["lockEndTime"] = this.lockEndTime ? this.lockEndTime.toISOString() : <any>undefined;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["currentLoginIp"] = this.currentLoginIp;
        data["currentLoginTime"] = this.currentLoginTime ? this.currentLoginTime.toISOString() : <any>undefined;
        data["lastLoginIp"] = this.lastLoginIp;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        if (this.visibilityOrganizationsIds && this.visibilityOrganizationsIds.constructor === Array) {
            data["visibilityOrganizationsIds"] = [];
            for (let item of this.visibilityOrganizationsIds)
                data["visibilityOrganizationsIds"].push(item);
        }
        if (this.positionIds && this.positionIds.constructor === Array) {
            data["positionIds"] = [];
            for (let item of this.positionIds)
                data["positionIds"].push(item);
        }
        data["creatorId"] = this.creatorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserCacheDto {
        const json = this.toJSON();
        let result = new UserCacheDto();
        result.init(json);
        return result;
    }
}

export interface IUserCacheDto {
    merchantId: string | undefined;
    merchantName: string | undefined;
    id: string | undefined;
    head: string | undefined;
    eid: string | undefined;
    eName: string | undefined;
    mobile: string | undefined;
    organizationsId: string | undefined;
    organizationsName: string | undefined;
    sex: UserCacheDtoSex | undefined;
    roleId: string | undefined;
    roleName: string | undefined;
    isLocked: boolean | undefined;
    lockBeginTime: moment.Moment | undefined;
    lockEndTime: moment.Moment | undefined;
    registerTime: moment.Moment | undefined;
    currentLoginIp: string | undefined;
    currentLoginTime: moment.Moment | undefined;
    lastLoginIp: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    visibilityOrganizationsIds: string[] | undefined;
    positionIds: string[] | undefined;
    creatorId: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierId: string | undefined;
    lastModificationTime: moment.Moment | undefined;
}

export class PagedAndFilteredInputDto implements IPagedAndFilteredInputDto {
    filterText: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IPagedAndFilteredInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filterText = data["filterText"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagedAndFilteredInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedAndFilteredInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterText"] = this.filterText;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): PagedAndFilteredInputDto {
        const json = this.toJSON();
        let result = new PagedAndFilteredInputDto();
        result.init(json);
        return result;
    }
}

export interface IPagedAndFilteredInputDto {
    filterText: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class DataSourceResult implements IDataSourceResult {
    data: any[] | undefined;
    group: any[] | undefined;
    total: number | undefined;
    aggregates: any | undefined;
    errors: any | undefined;

    constructor(data?: IDataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(item);
            }
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [];
                for (let item of data["group"])
                    this.group.push(item);
            }
            this.total = data["total"];
            this.aggregates = data["aggregates"];
            this.errors = data["errors"];
        }
    }

    static fromJS(data: any): DataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        data["total"] = this.total;
        data["aggregates"] = this.aggregates;
        data["errors"] = this.errors;
        return data; 
    }

    clone(): DataSourceResult {
        const json = this.toJSON();
        let result = new DataSourceResult();
        result.init(json);
        return result;
    }
}

export interface IDataSourceResult {
    data: any[] | undefined;
    group: any[] | undefined;
    total: number | undefined;
    aggregates: any | undefined;
    errors: any | undefined;
}

export class SpotCheckSetupDto implements ISpotCheckSetupDto {
    natureId: number | undefined;
    natureCode: string | undefined;
    natureName: string | undefined;
    displayOrder: number | undefined;
    ratio: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;

    constructor(data?: ISpotCheckSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.natureId = data["natureId"];
            this.natureCode = data["natureCode"];
            this.natureName = data["natureName"];
            this.displayOrder = data["displayOrder"];
            this.ratio = data["ratio"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
        }
    }

    static fromJS(data: any): SpotCheckSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpotCheckSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["natureId"] = this.natureId;
        data["natureCode"] = this.natureCode;
        data["natureName"] = this.natureName;
        data["displayOrder"] = this.displayOrder;
        data["ratio"] = this.ratio;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        return data; 
    }

    clone(): SpotCheckSetupDto {
        const json = this.toJSON();
        let result = new SpotCheckSetupDto();
        result.init(json);
        return result;
    }
}

export interface ISpotCheckSetupDto {
    natureId: number | undefined;
    natureCode: string | undefined;
    natureName: string | undefined;
    displayOrder: number | undefined;
    ratio: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
}

export class SpotChechSetupList implements ISpotChechSetupList {
    natureList: SpotCheckSetupDto[] | undefined;

    constructor(data?: ISpotChechSetupList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["natureList"] && data["natureList"].constructor === Array) {
                this.natureList = [];
                for (let item of data["natureList"])
                    this.natureList.push(SpotCheckSetupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpotChechSetupList {
        data = typeof data === 'object' ? data : {};
        let result = new SpotChechSetupList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.natureList && this.natureList.constructor === Array) {
            data["natureList"] = [];
            for (let item of this.natureList)
                data["natureList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SpotChechSetupList {
        const json = this.toJSON();
        let result = new SpotChechSetupList();
        result.init(json);
        return result;
    }
}

export interface ISpotChechSetupList {
    natureList: SpotCheckSetupDto[] | undefined;
}

export class SpotCheckSetup implements ISpotCheckSetup {
    natureId: number | undefined;
    ratio: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISpotCheckSetup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.natureId = data["natureId"];
            this.ratio = data["ratio"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SpotCheckSetup {
        data = typeof data === 'object' ? data : {};
        let result = new SpotCheckSetup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["natureId"] = this.natureId;
        data["ratio"] = this.ratio;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SpotCheckSetup {
        const json = this.toJSON();
        let result = new SpotCheckSetup();
        result.init(json);
        return result;
    }
}

export interface ISpotCheckSetup {
    natureId: number | undefined;
    ratio: number | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DataSourceRequest implements IDataSourceRequest {
    take: number | undefined;
    skip: number | undefined;
    sort: Sort[] | undefined;
    filter: Filter | undefined;
    group: Group[] | undefined;

    constructor(data?: IDataSourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.take = data["take"];
            this.skip = data["skip"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(Sort.fromJS(item));
            }
            this.filter = data["filter"] ? Filter.fromJS(data["filter"]) : <any>undefined;
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [];
                for (let item of data["group"])
                    this.group.push(Group.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataSourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["take"] = this.take;
        data["skip"] = this.skip;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DataSourceRequest {
        const json = this.toJSON();
        let result = new DataSourceRequest();
        result.init(json);
        return result;
    }
}

export interface IDataSourceRequest {
    take: number | undefined;
    skip: number | undefined;
    sort: Sort[] | undefined;
    filter: Filter | undefined;
    group: Group[] | undefined;
}

export class Sort implements ISort {
    field: string | undefined;
    dir: string | undefined;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.dir = data["dir"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["dir"] = this.dir;
        return data; 
    }

    clone(): Sort {
        const json = this.toJSON();
        let result = new Sort();
        result.init(json);
        return result;
    }
}

export interface ISort {
    field: string | undefined;
    dir: string | undefined;
}

export class Filter implements IFilter {
    field: string | undefined;
    operator: string | undefined;
    value: any | undefined;
    logic: string | undefined;
    filters: Filter[] | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.operator = data["operator"];
            this.value = data["value"];
            this.logic = data["logic"];
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(Filter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["value"] = this.value;
        data["logic"] = this.logic;
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Filter {
        const json = this.toJSON();
        let result = new Filter();
        result.init(json);
        return result;
    }
}

export interface IFilter {
    field: string | undefined;
    operator: string | undefined;
    value: any | undefined;
    logic: string | undefined;
    filters: Filter[] | undefined;
}

export class Group implements IGroup {
    aggregates: Aggregator[] | undefined;
    field: string | undefined;
    dir: string | undefined;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["aggregates"] && data["aggregates"].constructor === Array) {
                this.aggregates = [];
                for (let item of data["aggregates"])
                    this.aggregates.push(Aggregator.fromJS(item));
            }
            this.field = data["field"];
            this.dir = data["dir"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregates && this.aggregates.constructor === Array) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["field"] = this.field;
        data["dir"] = this.dir;
        return data; 
    }

    clone(): Group {
        const json = this.toJSON();
        let result = new Group();
        result.init(json);
        return result;
    }
}

export interface IGroup {
    aggregates: Aggregator[] | undefined;
    field: string | undefined;
    dir: string | undefined;
}

export class Aggregator implements IAggregator {
    field: string | undefined;
    aggregate: string | undefined;

    constructor(data?: IAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.aggregate = data["aggregate"];
        }
    }

    static fromJS(data: any): Aggregator {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["aggregate"] = this.aggregate;
        return data; 
    }

    clone(): Aggregator {
        const json = this.toJSON();
        let result = new Aggregator();
        result.init(json);
        return result;
    }
}

export interface IAggregator {
    field: string | undefined;
    aggregate: string | undefined;
}

export class ListResultDtoOfProjectCompanyListDto implements IListResultDtoOfProjectCompanyListDto {
    items: ProjectCompanyListDto[] | undefined;

    constructor(data?: IListResultDtoOfProjectCompanyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProjectCompanyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfProjectCompanyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfProjectCompanyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfProjectCompanyListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfProjectCompanyListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfProjectCompanyListDto {
    items: ProjectCompanyListDto[] | undefined;
}

export class ProjectCompanyListDto implements IProjectCompanyListDto {
    projectId: number | undefined;
    orgTypeId: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;
    id: number | undefined;

    constructor(data?: IProjectCompanyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.orgTypeId = data["orgTypeId"];
            this.companyName = data["companyName"];
            this.qualifications = data["qualifications"];
            this.legalRepresentative = data["legalRepresentative"];
            this.legalRepresentativeNo = data["legalRepresentativeNo"];
            this.contactPerson = data["contactPerson"];
            this.contactNumber = data["contactNumber"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectCompanyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCompanyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["orgTypeId"] = this.orgTypeId;
        data["companyName"] = this.companyName;
        data["qualifications"] = this.qualifications;
        data["legalRepresentative"] = this.legalRepresentative;
        data["legalRepresentativeNo"] = this.legalRepresentativeNo;
        data["contactPerson"] = this.contactPerson;
        data["contactNumber"] = this.contactNumber;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProjectCompanyListDto {
        const json = this.toJSON();
        let result = new ProjectCompanyListDto();
        result.init(json);
        return result;
    }
}

export interface IProjectCompanyListDto {
    projectId: number | undefined;
    orgTypeId: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;
    id: number | undefined;
}

export class CreateOrUpdateProjectCompanyInput implements ICreateOrUpdateProjectCompanyInput {
    projectCompany: ProjectCompanyEditDto;

    constructor(data?: ICreateOrUpdateProjectCompanyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectCompany = new ProjectCompanyEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.projectCompany = data["projectCompany"] ? ProjectCompanyEditDto.fromJS(data["projectCompany"]) : new ProjectCompanyEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateProjectCompanyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateProjectCompanyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCompany"] = this.projectCompany ? this.projectCompany.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateProjectCompanyInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateProjectCompanyInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateProjectCompanyInput {
    projectCompany: ProjectCompanyEditDto;
}

export class ProjectCompanyEditDto implements IProjectCompanyEditDto {
    id: number | undefined;
    projectId: number | undefined;
    orgTypeId: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;

    constructor(data?: IProjectCompanyEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.projectId = data["projectId"];
            this.orgTypeId = data["orgTypeId"];
            this.companyName = data["companyName"];
            this.qualifications = data["qualifications"];
            this.legalRepresentative = data["legalRepresentative"];
            this.legalRepresentativeNo = data["legalRepresentativeNo"];
            this.contactPerson = data["contactPerson"];
            this.contactNumber = data["contactNumber"];
        }
    }

    static fromJS(data: any): ProjectCompanyEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCompanyEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["orgTypeId"] = this.orgTypeId;
        data["companyName"] = this.companyName;
        data["qualifications"] = this.qualifications;
        data["legalRepresentative"] = this.legalRepresentative;
        data["legalRepresentativeNo"] = this.legalRepresentativeNo;
        data["contactPerson"] = this.contactPerson;
        data["contactNumber"] = this.contactNumber;
        return data; 
    }

    clone(): ProjectCompanyEditDto {
        const json = this.toJSON();
        let result = new ProjectCompanyEditDto();
        result.init(json);
        return result;
    }
}

export interface IProjectCompanyEditDto {
    id: number | undefined;
    projectId: number | undefined;
    orgTypeId: number | undefined;
    companyName: string | undefined;
    qualifications: string | undefined;
    legalRepresentative: string | undefined;
    legalRepresentativeNo: string | undefined;
    contactPerson: string | undefined;
    contactNumber: string | undefined;
}

export class ProjectFlowItemQueryDto implements IProjectFlowItemQueryDto {
    projectCode: string | undefined;
    projectName: string | undefined;
    constructOrgName: string | undefined;
    status: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IProjectFlowItemQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectCode = data["projectCode"];
            this.projectName = data["projectName"];
            this.constructOrgName = data["constructOrgName"];
            this.status = data["status"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectFlowItemQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowItemQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["constructOrgName"] = this.constructOrgName;
        data["status"] = this.status;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): ProjectFlowItemQueryDto {
        const json = this.toJSON();
        let result = new ProjectFlowItemQueryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowItemQueryDto {
    projectCode: string | undefined;
    projectName: string | undefined;
    constructOrgName: string | undefined;
    status: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class DraftQueryDto implements IDraftQueryDto {
    number: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    applyTimeStart: moment.Moment | undefined;
    applyTimeEnd: moment.Moment | undefined;
    filterText: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IDraftQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.number = data["number"];
            this.projectName = data["projectName"];
            this.companyName = data["companyName"];
            this.applyTimeStart = data["applyTimeStart"] ? moment(data["applyTimeStart"].toString()) : <any>undefined;
            this.applyTimeEnd = data["applyTimeEnd"] ? moment(data["applyTimeEnd"].toString()) : <any>undefined;
            this.filterText = data["filterText"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): DraftQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DraftQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["projectName"] = this.projectName;
        data["companyName"] = this.companyName;
        data["applyTimeStart"] = this.applyTimeStart ? this.applyTimeStart.toISOString() : <any>undefined;
        data["applyTimeEnd"] = this.applyTimeEnd ? this.applyTimeEnd.toISOString() : <any>undefined;
        data["filterText"] = this.filterText;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DraftQueryDto {
        const json = this.toJSON();
        let result = new DraftQueryDto();
        result.init(json);
        return result;
    }
}

export interface IDraftQueryDto {
    number: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    applyTimeStart: moment.Moment | undefined;
    applyTimeEnd: moment.Moment | undefined;
    filterText: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ProjectFlowIndexTopQueryDto implements IProjectFlowIndexTopQueryDto {
    processedStatus: number | undefined;
    fireAuditStatus: number | undefined;
    fireCompleteStatus: number | undefined;
    completeStatus: number | undefined;
    dateTimeNow: moment.Moment | undefined;

    constructor(data?: IProjectFlowIndexTopQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processedStatus = data["processedStatus"];
            this.fireAuditStatus = data["fireAuditStatus"];
            this.fireCompleteStatus = data["fireCompleteStatus"];
            this.completeStatus = data["completeStatus"];
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectFlowIndexTopQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowIndexTopQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedStatus"] = this.processedStatus;
        data["fireAuditStatus"] = this.fireAuditStatus;
        data["fireCompleteStatus"] = this.fireCompleteStatus;
        data["completeStatus"] = this.completeStatus;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectFlowIndexTopQueryDto {
        const json = this.toJSON();
        let result = new ProjectFlowIndexTopQueryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowIndexTopQueryDto {
    processedStatus: number | undefined;
    fireAuditStatus: number | undefined;
    fireCompleteStatus: number | undefined;
    completeStatus: number | undefined;
    dateTimeNow: moment.Moment | undefined;
}

export class ProjectFlowIndexTopDto implements IProjectFlowIndexTopDto {
    processedCount: number | undefined;
    timeoutCount: number | undefined;
    fireAuditCount: number | undefined;
    fireCompleteCount: number | undefined;
    completeCount: number | undefined;

    constructor(data?: IProjectFlowIndexTopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processedCount = data["processedCount"];
            this.timeoutCount = data["timeoutCount"];
            this.fireAuditCount = data["fireAuditCount"];
            this.fireCompleteCount = data["fireCompleteCount"];
            this.completeCount = data["completeCount"];
        }
    }

    static fromJS(data: any): ProjectFlowIndexTopDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowIndexTopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedCount"] = this.processedCount;
        data["timeoutCount"] = this.timeoutCount;
        data["fireAuditCount"] = this.fireAuditCount;
        data["fireCompleteCount"] = this.fireCompleteCount;
        data["completeCount"] = this.completeCount;
        return data; 
    }

    clone(): ProjectFlowIndexTopDto {
        const json = this.toJSON();
        let result = new ProjectFlowIndexTopDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowIndexTopDto {
    processedCount: number | undefined;
    timeoutCount: number | undefined;
    fireAuditCount: number | undefined;
    fireCompleteCount: number | undefined;
    completeCount: number | undefined;
}

export class ProjectTimeoutQueryDto implements IProjectTimeoutQueryDto {
    processedStatus: number | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IProjectTimeoutQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processedStatus = data["processedStatus"];
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectTimeoutQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTimeoutQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedStatus"] = this.processedStatus;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): ProjectTimeoutQueryDto {
        const json = this.toJSON();
        let result = new ProjectTimeoutQueryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectTimeoutQueryDto {
    processedStatus: number | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ProjectFlowDataStatisticsQueryDto implements IProjectFlowDataStatisticsQueryDto {
    stateDate: moment.Moment | undefined;
    statisticsType: number | undefined;

    constructor(data?: IProjectFlowDataStatisticsQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stateDate = data["stateDate"] ? moment(data["stateDate"].toString()) : <any>undefined;
            this.statisticsType = data["statisticsType"];
        }
    }

    static fromJS(data: any): ProjectFlowDataStatisticsQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowDataStatisticsQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateDate"] = this.stateDate ? this.stateDate.toISOString() : <any>undefined;
        data["statisticsType"] = this.statisticsType;
        return data; 
    }

    clone(): ProjectFlowDataStatisticsQueryDto {
        const json = this.toJSON();
        let result = new ProjectFlowDataStatisticsQueryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowDataStatisticsQueryDto {
    stateDate: moment.Moment | undefined;
    statisticsType: number | undefined;
}

export class ProjectFlowStatisticsDto implements IProjectFlowStatisticsDto {
    currentMonthCount: number | undefined;
    currentWeekCount: number | undefined;
    comparedMonthRate: number | undefined;
    comparedWeekRate: number | undefined;
    items: ProjectFlowStatisticsDayDto[] | undefined;

    constructor(data?: IProjectFlowStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentMonthCount = data["currentMonthCount"];
            this.currentWeekCount = data["currentWeekCount"];
            this.comparedMonthRate = data["comparedMonthRate"];
            this.comparedWeekRate = data["comparedWeekRate"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProjectFlowStatisticsDayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectFlowStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentMonthCount"] = this.currentMonthCount;
        data["currentWeekCount"] = this.currentWeekCount;
        data["comparedMonthRate"] = this.comparedMonthRate;
        data["comparedWeekRate"] = this.comparedWeekRate;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProjectFlowStatisticsDto {
        const json = this.toJSON();
        let result = new ProjectFlowStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowStatisticsDto {
    currentMonthCount: number | undefined;
    currentWeekCount: number | undefined;
    comparedMonthRate: number | undefined;
    comparedWeekRate: number | undefined;
    items: ProjectFlowStatisticsDayDto[] | undefined;
}

export class ProjectFlowStatisticsDayDto implements IProjectFlowStatisticsDayDto {
    dayCount: number | undefined;
    dayTime: string | undefined;

    constructor(data?: IProjectFlowStatisticsDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dayCount = data["dayCount"];
            this.dayTime = data["dayTime"];
        }
    }

    static fromJS(data: any): ProjectFlowStatisticsDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFlowStatisticsDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dayCount"] = this.dayCount;
        data["dayTime"] = this.dayTime;
        return data; 
    }

    clone(): ProjectFlowStatisticsDayDto {
        const json = this.toJSON();
        let result = new ProjectFlowStatisticsDayDto();
        result.init(json);
        return result;
    }
}

export interface IProjectFlowStatisticsDayDto {
    dayCount: number | undefined;
    dayTime: string | undefined;
}

export class FireAuditCompleteQueryDto implements IFireAuditCompleteQueryDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    status: number | undefined;
    flowPathType: number | undefined;
    orgType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IFireAuditCompleteQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordNumber = data["recordNumber"];
            this.projectName = data["projectName"];
            this.companyName = data["companyName"];
            this.status = data["status"];
            this.flowPathType = data["flowPathType"];
            this.orgType = data["orgType"];
            this.startApplyTime = data["startApplyTime"] ? moment(data["startApplyTime"].toString()) : <any>undefined;
            this.endApplyTime = data["endApplyTime"] ? moment(data["endApplyTime"].toString()) : <any>undefined;
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): FireAuditCompleteQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FireAuditCompleteQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordNumber"] = this.recordNumber;
        data["projectName"] = this.projectName;
        data["companyName"] = this.companyName;
        data["status"] = this.status;
        data["flowPathType"] = this.flowPathType;
        data["orgType"] = this.orgType;
        data["startApplyTime"] = this.startApplyTime ? this.startApplyTime.toISOString() : <any>undefined;
        data["endApplyTime"] = this.endApplyTime ? this.endApplyTime.toISOString() : <any>undefined;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): FireAuditCompleteQueryDto {
        const json = this.toJSON();
        let result = new FireAuditCompleteQueryDto();
        result.init(json);
        return result;
    }
}

export interface IFireAuditCompleteQueryDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    status: number | undefined;
    flowPathType: number | undefined;
    orgType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class StatisticsQueryDto implements IStatisticsQueryDto {
    projectCode: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IStatisticsQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectCode = data["projectCode"];
            this.projectName = data["projectName"];
            this.companyName = data["companyName"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): StatisticsQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["companyName"] = this.companyName;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): StatisticsQueryDto {
        const json = this.toJSON();
        let result = new StatisticsQueryDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticsQueryDto {
    projectCode: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ListResultDtoOfRegulationListDto implements IListResultDtoOfRegulationListDto {
    items: RegulationListDto[] | undefined;

    constructor(data?: IListResultDtoOfRegulationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RegulationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRegulationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRegulationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRegulationListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRegulationListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRegulationListDto {
    items: RegulationListDto[] | undefined;
}

export class RegulationListDto implements IRegulationListDto {
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationTypeId: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    id: number | undefined;

    constructor(data?: IRegulationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.regulationCode = data["regulationCode"];
            this.title = data["title"];
            this.issueOrg = data["issueOrg"];
            this.regulationTypeId = data["regulationTypeId"];
            this.issueDate = data["issueDate"] ? moment(data["issueDate"].toString()) : <any>undefined;
            this.contentUrl = data["contentUrl"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RegulationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegulationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regulationCode"] = this.regulationCode;
        data["title"] = this.title;
        data["issueOrg"] = this.issueOrg;
        data["regulationTypeId"] = this.regulationTypeId;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["contentUrl"] = this.contentUrl;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        data["id"] = this.id;
        return data; 
    }

    clone(): RegulationListDto {
        const json = this.toJSON();
        let result = new RegulationListDto();
        result.init(json);
        return result;
    }
}

export interface IRegulationListDto {
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationTypeId: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
    id: number | undefined;
}

export class CreateOrUpdateRegulationInput implements ICreateOrUpdateRegulationInput {
    regulation: RegulationEditDto;

    constructor(data?: ICreateOrUpdateRegulationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.regulation = new RegulationEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.regulation = data["regulation"] ? RegulationEditDto.fromJS(data["regulation"]) : new RegulationEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateRegulationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRegulationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regulation"] = this.regulation ? this.regulation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateRegulationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRegulationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRegulationInput {
    regulation: RegulationEditDto;
}

export class RegulationEditDto implements IRegulationEditDto {
    id: number | undefined;
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationTypeId: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;

    constructor(data?: IRegulationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.regulationCode = data["regulationCode"];
            this.title = data["title"];
            this.issueOrg = data["issueOrg"];
            this.regulationTypeId = data["regulationTypeId"];
            this.issueDate = data["issueDate"] ? moment(data["issueDate"].toString()) : <any>undefined;
            this.contentUrl = data["contentUrl"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.lastUpdateUserCode = data["lastUpdateUserCode"];
            this.lastUpdateUserName = data["lastUpdateUserName"];
        }
    }

    static fromJS(data: any): RegulationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegulationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["regulationCode"] = this.regulationCode;
        data["title"] = this.title;
        data["issueOrg"] = this.issueOrg;
        data["regulationTypeId"] = this.regulationTypeId;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["contentUrl"] = this.contentUrl;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["lastUpdateUserCode"] = this.lastUpdateUserCode;
        data["lastUpdateUserName"] = this.lastUpdateUserName;
        return data; 
    }

    clone(): RegulationEditDto {
        const json = this.toJSON();
        let result = new RegulationEditDto();
        result.init(json);
        return result;
    }
}

export interface IRegulationEditDto {
    id: number | undefined;
    regulationCode: string | undefined;
    title: string | undefined;
    issueOrg: string | undefined;
    regulationTypeId: string | undefined;
    issueDate: moment.Moment | undefined;
    contentUrl: string | undefined;
    lastUpdateTime: moment.Moment | undefined;
    lastUpdateUserCode: string | undefined;
    lastUpdateUserName: string | undefined;
}

export class KeyValueDto implements IKeyValueDto {
    key: string | undefined;
    value: string | undefined;

    constructor(data?: IKeyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): KeyValueDto {
        const json = this.toJSON();
        let result = new KeyValueDto();
        result.init(json);
        return result;
    }
}

export interface IKeyValueDto {
    key: string | undefined;
    value: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class ApplyStatisticsQueryDto implements IApplyStatisticsQueryDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;

    constructor(data?: IApplyStatisticsQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplyStatisticsQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyStatisticsQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ApplyStatisticsQueryDto {
        const json = this.toJSON();
        let result = new ApplyStatisticsQueryDto();
        result.init(json);
        return result;
    }
}

export interface IApplyStatisticsQueryDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class ApplyStatisticsDto implements IApplyStatisticsDto {
    statisticsNumberCount: number | undefined;
    fireCompleteNumberCount: number | undefined;
    completeNumberCount: number | undefined;
    hasStatisticsNumber: number | undefined;
    notStatisticsNumber: number | undefined;
    hasFireCompleteNumber: number | undefined;
    notFireCompleteNumber: number | undefined;
    hasCompleteNumber: number | undefined;
    notCompleteNumber: number | undefined;

    constructor(data?: IApplyStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statisticsNumberCount = data["statisticsNumberCount"];
            this.fireCompleteNumberCount = data["fireCompleteNumberCount"];
            this.completeNumberCount = data["completeNumberCount"];
            this.hasStatisticsNumber = data["hasStatisticsNumber"];
            this.notStatisticsNumber = data["notStatisticsNumber"];
            this.hasFireCompleteNumber = data["hasFireCompleteNumber"];
            this.notFireCompleteNumber = data["notFireCompleteNumber"];
            this.hasCompleteNumber = data["hasCompleteNumber"];
            this.notCompleteNumber = data["notCompleteNumber"];
        }
    }

    static fromJS(data: any): ApplyStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statisticsNumberCount"] = this.statisticsNumberCount;
        data["fireCompleteNumberCount"] = this.fireCompleteNumberCount;
        data["completeNumberCount"] = this.completeNumberCount;
        data["hasStatisticsNumber"] = this.hasStatisticsNumber;
        data["notStatisticsNumber"] = this.notStatisticsNumber;
        data["hasFireCompleteNumber"] = this.hasFireCompleteNumber;
        data["notFireCompleteNumber"] = this.notFireCompleteNumber;
        data["hasCompleteNumber"] = this.hasCompleteNumber;
        data["notCompleteNumber"] = this.notCompleteNumber;
        return data; 
    }

    clone(): ApplyStatisticsDto {
        const json = this.toJSON();
        let result = new ApplyStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface IApplyStatisticsDto {
    statisticsNumberCount: number | undefined;
    fireCompleteNumberCount: number | undefined;
    completeNumberCount: number | undefined;
    hasStatisticsNumber: number | undefined;
    notStatisticsNumber: number | undefined;
    hasFireCompleteNumber: number | undefined;
    notFireCompleteNumber: number | undefined;
    hasCompleteNumber: number | undefined;
    notCompleteNumber: number | undefined;
}

export class DeclareRateQueryDto implements IDeclareRateQueryDto {
    processedStatus: number | undefined;

    constructor(data?: IDeclareRateQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processedStatus = data["processedStatus"];
        }
    }

    static fromJS(data: any): DeclareRateQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeclareRateQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedStatus"] = this.processedStatus;
        return data; 
    }

    clone(): DeclareRateQueryDto {
        const json = this.toJSON();
        let result = new DeclareRateQueryDto();
        result.init(json);
        return result;
    }
}

export interface IDeclareRateQueryDto {
    processedStatus: number | undefined;
}

export class ListResultDtoOfTimeoutStatisticsDto implements IListResultDtoOfTimeoutStatisticsDto {
    items: TimeoutStatisticsDto[] | undefined;

    constructor(data?: IListResultDtoOfTimeoutStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TimeoutStatisticsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfTimeoutStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfTimeoutStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfTimeoutStatisticsDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfTimeoutStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfTimeoutStatisticsDto {
    items: TimeoutStatisticsDto[] | undefined;
}

export class TimeoutStatisticsDto implements ITimeoutStatisticsDto {
    cityName: string | undefined;
    flowPathType: number | undefined;
    fireAuditNumber: number | undefined;
    fireCompleteNumber: number | undefined;
    completeNumber: number | undefined;

    constructor(data?: ITimeoutStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityName = data["cityName"];
            this.flowPathType = data["flowPathType"];
            this.fireAuditNumber = data["fireAuditNumber"];
            this.fireCompleteNumber = data["fireCompleteNumber"];
            this.completeNumber = data["completeNumber"];
        }
    }

    static fromJS(data: any): TimeoutStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeoutStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityName"] = this.cityName;
        data["flowPathType"] = this.flowPathType;
        data["fireAuditNumber"] = this.fireAuditNumber;
        data["fireCompleteNumber"] = this.fireCompleteNumber;
        data["completeNumber"] = this.completeNumber;
        return data; 
    }

    clone(): TimeoutStatisticsDto {
        const json = this.toJSON();
        let result = new TimeoutStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface ITimeoutStatisticsDto {
    cityName: string | undefined;
    flowPathType: number | undefined;
    fireAuditNumber: number | undefined;
    fireCompleteNumber: number | undefined;
    completeNumber: number | undefined;
}

export class ScreenTimeoutStatisticsQueryDto implements IScreenTimeoutStatisticsQueryDto {
    dateTimeNow: moment.Moment | undefined;

    constructor(data?: IScreenTimeoutStatisticsQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScreenTimeoutStatisticsQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenTimeoutStatisticsQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ScreenTimeoutStatisticsQueryDto {
        const json = this.toJSON();
        let result = new ScreenTimeoutStatisticsQueryDto();
        result.init(json);
        return result;
    }
}

export interface IScreenTimeoutStatisticsQueryDto {
    dateTimeNow: moment.Moment | undefined;
}

export class ListResultDtoOfATimeByStatisticsDto implements IListResultDtoOfATimeByStatisticsDto {
    items: ATimeByStatisticsDto[] | undefined;

    constructor(data?: IListResultDtoOfATimeByStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ATimeByStatisticsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfATimeByStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfATimeByStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfATimeByStatisticsDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfATimeByStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfATimeByStatisticsDto {
    items: ATimeByStatisticsDto[] | undefined;
}

export class ATimeByStatisticsDto implements IATimeByStatisticsDto {
    cityName: string | undefined;
    flowPathType: number | undefined;
    throughRate: number | undefined;

    constructor(data?: IATimeByStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityName = data["cityName"];
            this.flowPathType = data["flowPathType"];
            this.throughRate = data["throughRate"];
        }
    }

    static fromJS(data: any): ATimeByStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ATimeByStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityName"] = this.cityName;
        data["flowPathType"] = this.flowPathType;
        data["throughRate"] = this.throughRate;
        return data; 
    }

    clone(): ATimeByStatisticsDto {
        const json = this.toJSON();
        let result = new ATimeByStatisticsDto();
        result.init(json);
        return result;
    }
}

export interface IATimeByStatisticsDto {
    cityName: string | undefined;
    flowPathType: number | undefined;
    throughRate: number | undefined;
}

export class ScreenTimeoutListQueryDto implements IScreenTimeoutListQueryDto {
    dateTimeNow: moment.Moment | undefined;
    orderStatus: number | undefined;
    orgType: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IScreenTimeoutListQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.orderStatus = data["orderStatus"];
            this.orgType = data["orgType"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ScreenTimeoutListQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenTimeoutListQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["orgType"] = this.orgType;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): ScreenTimeoutListQueryDto {
        const json = this.toJSON();
        let result = new ScreenTimeoutListQueryDto();
        result.init(json);
        return result;
    }
}

export interface IScreenTimeoutListQueryDto {
    dateTimeNow: moment.Moment | undefined;
    orderStatus: number | undefined;
    orgType: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class YearApplyNumberQueryDto implements IYearApplyNumberQueryDto {
    dateTimeNow: moment.Moment | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    completeStatus: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IYearApplyNumberQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.completeStatus = data["completeStatus"];
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): YearApplyNumberQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new YearApplyNumberQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["completeStatus"] = this.completeStatus;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): YearApplyNumberQueryDto {
        const json = this.toJSON();
        let result = new YearApplyNumberQueryDto();
        result.init(json);
        return result;
    }
}

export interface IYearApplyNumberQueryDto {
    dateTimeNow: moment.Moment | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    completeStatus: number | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class FireDataListQueryDto implements IFireDataListQueryDto {
    statisticsType: number | undefined;
    dateTimeNow: moment.Moment | undefined;
    processedStatus: number | undefined;

    constructor(data?: IFireDataListQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statisticsType = data["statisticsType"];
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.processedStatus = data["processedStatus"];
        }
    }

    static fromJS(data: any): FireDataListQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FireDataListQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statisticsType"] = this.statisticsType;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["processedStatus"] = this.processedStatus;
        return data; 
    }

    clone(): FireDataListQueryDto {
        const json = this.toJSON();
        let result = new FireDataListQueryDto();
        result.init(json);
        return result;
    }
}

export interface IFireDataListQueryDto {
    statisticsType: number | undefined;
    dateTimeNow: moment.Moment | undefined;
    processedStatus: number | undefined;
}

export class FireDataListDto implements IFireDataListDto {
    completeCountNumber: number | undefined;
    timeoutCountNumber: number | undefined;
    aTimeByCountNumber: number | undefined;
    avgCompleteTimeCountNumber: number | undefined;
    items: CityFireDataList[] | undefined;

    constructor(data?: IFireDataListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.completeCountNumber = data["completeCountNumber"];
            this.timeoutCountNumber = data["timeoutCountNumber"];
            this.aTimeByCountNumber = data["aTimeByCountNumber"];
            this.avgCompleteTimeCountNumber = data["avgCompleteTimeCountNumber"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CityFireDataList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FireDataListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FireDataListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["completeCountNumber"] = this.completeCountNumber;
        data["timeoutCountNumber"] = this.timeoutCountNumber;
        data["aTimeByCountNumber"] = this.aTimeByCountNumber;
        data["avgCompleteTimeCountNumber"] = this.avgCompleteTimeCountNumber;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FireDataListDto {
        const json = this.toJSON();
        let result = new FireDataListDto();
        result.init(json);
        return result;
    }
}

export interface IFireDataListDto {
    completeCountNumber: number | undefined;
    timeoutCountNumber: number | undefined;
    aTimeByCountNumber: number | undefined;
    avgCompleteTimeCountNumber: number | undefined;
    items: CityFireDataList[] | undefined;
}

export class CityFireDataList implements ICityFireDataList {
    cityName: string | undefined;
    completeCountNumber: number | undefined;
    timeoutCountNumber: number | undefined;
    aTimeByCountNumber: number | undefined;
    avgCompleteTimeCountNumber: number | undefined;

    constructor(data?: ICityFireDataList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityName = data["cityName"];
            this.completeCountNumber = data["completeCountNumber"];
            this.timeoutCountNumber = data["timeoutCountNumber"];
            this.aTimeByCountNumber = data["aTimeByCountNumber"];
            this.avgCompleteTimeCountNumber = data["avgCompleteTimeCountNumber"];
        }
    }

    static fromJS(data: any): CityFireDataList {
        data = typeof data === 'object' ? data : {};
        let result = new CityFireDataList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityName"] = this.cityName;
        data["completeCountNumber"] = this.completeCountNumber;
        data["timeoutCountNumber"] = this.timeoutCountNumber;
        data["aTimeByCountNumber"] = this.aTimeByCountNumber;
        data["avgCompleteTimeCountNumber"] = this.avgCompleteTimeCountNumber;
        return data; 
    }

    clone(): CityFireDataList {
        const json = this.toJSON();
        let result = new CityFireDataList();
        result.init(json);
        return result;
    }
}

export interface ICityFireDataList {
    cityName: string | undefined;
    completeCountNumber: number | undefined;
    timeoutCountNumber: number | undefined;
    aTimeByCountNumber: number | undefined;
    avgCompleteTimeCountNumber: number | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class WarningCenterQueryDto implements IWarningCenterQueryDto {
    flowNo: string | undefined;
    projectName: string | undefined;
    flowPathType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IWarningCenterQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flowNo = data["flowNo"];
            this.projectName = data["projectName"];
            this.flowPathType = data["flowPathType"];
            this.startApplyTime = data["startApplyTime"] ? moment(data["startApplyTime"].toString()) : <any>undefined;
            this.endApplyTime = data["endApplyTime"] ? moment(data["endApplyTime"].toString()) : <any>undefined;
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): WarningCenterQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarningCenterQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowNo"] = this.flowNo;
        data["projectName"] = this.projectName;
        data["flowPathType"] = this.flowPathType;
        data["startApplyTime"] = this.startApplyTime ? this.startApplyTime.toISOString() : <any>undefined;
        data["endApplyTime"] = this.endApplyTime ? this.endApplyTime.toISOString() : <any>undefined;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): WarningCenterQueryDto {
        const json = this.toJSON();
        let result = new WarningCenterQueryDto();
        result.init(json);
        return result;
    }
}

export interface IWarningCenterQueryDto {
    flowNo: string | undefined;
    projectName: string | undefined;
    flowPathType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ProjectApplyQueryDto implements IProjectApplyQueryDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    status: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IProjectApplyQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordNumber = data["recordNumber"];
            this.projectName = data["projectName"];
            this.status = data["status"];
            this.startApplyTime = data["startApplyTime"] ? moment(data["startApplyTime"].toString()) : <any>undefined;
            this.endApplyTime = data["endApplyTime"] ? moment(data["endApplyTime"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectApplyQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectApplyQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordNumber"] = this.recordNumber;
        data["projectName"] = this.projectName;
        data["status"] = this.status;
        data["startApplyTime"] = this.startApplyTime ? this.startApplyTime.toISOString() : <any>undefined;
        data["endApplyTime"] = this.endApplyTime ? this.endApplyTime.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): ProjectApplyQueryDto {
        const json = this.toJSON();
        let result = new ProjectApplyQueryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectApplyQueryDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    status: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class TimeoutQuetyDto implements ITimeoutQuetyDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    status: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: ITimeoutQuetyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordNumber = data["recordNumber"];
            this.projectName = data["projectName"];
            this.status = data["status"];
            this.startApplyTime = data["startApplyTime"] ? moment(data["startApplyTime"].toString()) : <any>undefined;
            this.endApplyTime = data["endApplyTime"] ? moment(data["endApplyTime"].toString()) : <any>undefined;
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): TimeoutQuetyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeoutQuetyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordNumber"] = this.recordNumber;
        data["projectName"] = this.projectName;
        data["status"] = this.status;
        data["startApplyTime"] = this.startApplyTime ? this.startApplyTime.toISOString() : <any>undefined;
        data["endApplyTime"] = this.endApplyTime ? this.endApplyTime.toISOString() : <any>undefined;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): TimeoutQuetyDto {
        const json = this.toJSON();
        let result = new TimeoutQuetyDto();
        result.init(json);
        return result;
    }
}

export interface ITimeoutQuetyDto {
    recordNumber: string | undefined;
    projectName: string | undefined;
    status: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class HandleLimitQueryDto implements IHandleLimitQueryDto {
    cityName: string | undefined;
    area: string | undefined;
    flowPathType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IHandleLimitQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityName = data["cityName"];
            this.area = data["area"];
            this.flowPathType = data["flowPathType"];
            this.startApplyTime = data["startApplyTime"] ? moment(data["startApplyTime"].toString()) : <any>undefined;
            this.endApplyTime = data["endApplyTime"] ? moment(data["endApplyTime"].toString()) : <any>undefined;
            this.dateTimeNow = data["dateTimeNow"] ? moment(data["dateTimeNow"].toString()) : <any>undefined;
            this.page = data["page"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): HandleLimitQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandleLimitQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityName"] = this.cityName;
        data["area"] = this.area;
        data["flowPathType"] = this.flowPathType;
        data["startApplyTime"] = this.startApplyTime ? this.startApplyTime.toISOString() : <any>undefined;
        data["endApplyTime"] = this.endApplyTime ? this.endApplyTime.toISOString() : <any>undefined;
        data["dateTimeNow"] = this.dateTimeNow ? this.dateTimeNow.toISOString() : <any>undefined;
        data["page"] = this.page;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): HandleLimitQueryDto {
        const json = this.toJSON();
        let result = new HandleLimitQueryDto();
        result.init(json);
        return result;
    }
}

export interface IHandleLimitQueryDto {
    cityName: string | undefined;
    area: string | undefined;
    flowPathType: number | undefined;
    startApplyTime: moment.Moment | undefined;
    endApplyTime: moment.Moment | undefined;
    dateTimeNow: moment.Moment | undefined;
    page: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    adminPassword: string | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.adminPassword = data["adminPassword"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["adminPassword"] = this.adminPassword;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    adminPassword: string | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export class PendingWorkFlow_NodeAuditorRecordDto implements IPendingWorkFlow_NodeAuditorRecordDto {
    pagedAndFilteredInputDto: PagedAndFilteredInputDto | undefined;
    number: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    applyTimeStart: moment.Moment | undefined;
    applyTimeEnd: moment.Moment | undefined;
    projectTypeStatu: number | undefined;
    isAlreadyDone: boolean | undefined;

    constructor(data?: IPendingWorkFlow_NodeAuditorRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pagedAndFilteredInputDto = data["pagedAndFilteredInputDto"] ? PagedAndFilteredInputDto.fromJS(data["pagedAndFilteredInputDto"]) : <any>undefined;
            this.number = data["number"];
            this.projectName = data["projectName"];
            this.companyName = data["companyName"];
            this.applyTimeStart = data["applyTimeStart"] ? moment(data["applyTimeStart"].toString()) : <any>undefined;
            this.applyTimeEnd = data["applyTimeEnd"] ? moment(data["applyTimeEnd"].toString()) : <any>undefined;
            this.projectTypeStatu = data["projectTypeStatu"];
            this.isAlreadyDone = data["isAlreadyDone"];
        }
    }

    static fromJS(data: any): PendingWorkFlow_NodeAuditorRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingWorkFlow_NodeAuditorRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagedAndFilteredInputDto"] = this.pagedAndFilteredInputDto ? this.pagedAndFilteredInputDto.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["projectName"] = this.projectName;
        data["companyName"] = this.companyName;
        data["applyTimeStart"] = this.applyTimeStart ? this.applyTimeStart.toISOString() : <any>undefined;
        data["applyTimeEnd"] = this.applyTimeEnd ? this.applyTimeEnd.toISOString() : <any>undefined;
        data["projectTypeStatu"] = this.projectTypeStatu;
        data["isAlreadyDone"] = this.isAlreadyDone;
        return data; 
    }

    clone(): PendingWorkFlow_NodeAuditorRecordDto {
        const json = this.toJSON();
        let result = new PendingWorkFlow_NodeAuditorRecordDto();
        result.init(json);
        return result;
    }
}

export interface IPendingWorkFlow_NodeAuditorRecordDto {
    pagedAndFilteredInputDto: PagedAndFilteredInputDto | undefined;
    number: string | undefined;
    projectName: string | undefined;
    companyName: string | undefined;
    applyTimeStart: moment.Moment | undefined;
    applyTimeEnd: moment.Moment | undefined;
    projectTypeStatu: number | undefined;
    isAlreadyDone: boolean | undefined;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum UserCacheDtoSex {
    _0 = 0, 
    _1 = 1, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}